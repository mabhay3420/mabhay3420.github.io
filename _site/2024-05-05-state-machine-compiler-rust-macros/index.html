<!DOCTYPE html>
<html lang="en">
<!-- Beautiful Jekyll 5.0.0 | Copyright Dean Attali 2020 -->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  

  

  <title>State Machine Compiler - Rust Macros</title>

  
  <meta name="author" content="Abhay mishra">
  

  <meta name="description" content="Generating code via macros">

  

  
  <meta name="keywords" content="deep-learning,Machine Learning, Web Developement, Tech Blog, Compilers">
  

  <link rel="alternate" type="application/rss+xml" title="Abhay's Blog" href="http://localhost:4000/feed.xml">

  

  

  


  
    
      
  <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">


    
      
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css">


    
      
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic">


    
      
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800">


    
  

  
    
      <link rel="stylesheet" href="/assets/css/bootstrap-social.css">
    
      <link rel="stylesheet" href="/assets/css/beautifuljekyll.css">
    
  

  

  
  
  

  

  
  <meta property="og:site_name" content="Abhay's Blog">
  <meta property="og:title" content="State Machine Compiler - Rust Macros">
  <meta property="og:description" content="Generating code via macros">

  
  <meta property="og:image" content="https://source.unsplash.com/featured/1920x1080/">
  

  
  <meta property="og:type" content="article">
  <meta property="og:article:author" content="Abhay mishra">
  <meta property="og:article:published_time" content="2024-05-05T00:00:00+05:30">
  <meta property="og:url" content="http://localhost:4000/2024-05-05-state-machine-compiler-rust-macros/">
  <link rel="canonical" href="http://localhost:4000/2024-05-05-state-machine-compiler-rust-macros/">
  

  
  <meta name="twitter:card" content="summary_large_image">
  
  <meta name="twitter:site" content="@">
  <meta name="twitter:creator" content="@">

  <meta property="twitter:title" content="State Machine Compiler - Rust Macros">
  <meta property="twitter:description" content="Generating code via macros">

  
  <meta name="twitter:image" content="https://source.unsplash.com/featured/1920x1080/">
  

  


  

  

  <!-- for mathjax support -->
    
      <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
        TeX: { equationNumbers: { autoNumber: "AMS" } }
        });
      </script>
      <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    

</head>


<body>

  


  <nav class="navbar navbar-expand-xl navbar-light fixed-top navbar-custom top-nav-regular"><a class="navbar-brand" href="http://localhost:4000/">Abhay's Blog</a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  <div class="collapse navbar-collapse" id="main-navbar">
    <ul class="navbar-nav ml-auto">
          <li class="nav-item">
            <a class="nav-link" href="/">Home</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/aboutme">About Me</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/project">Projects</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/resource">Resources</a>
          </li></ul>
  </div>

  

  

</nav>


  <!-- TODO this file has become a mess, refactor it -->






  <div id="header-big-imgs" data-num-img=1
    
    
    
      
      data-img-src-1="https://source.unsplash.com/featured/1920x1080/"
    
    
    
  ></div>


<header class="header-section has-img">

<div class="big-img intro-header">
  <div class="container-md">
    <div class="row">
      <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
        <div class="post-heading">
          <h1>State Machine Compiler - Rust Macros</h1>
          
            
              <h2 class="post-subheading">Generating code via macros</h2>
            
          

          
            <span class="post-meta">Posted on May 5, 2024</span>
            
            
              <!--- "ReadTime on GitHub Jekyll" (c) 2020 Ruby Griffith Ramirez, MIT License -->






  
  <span class="post-meta"><span class="d-none d-md-inline middot">&middot;</span> 13 minute read</span>


            
          
        </div>
      </div>
    </div>
  </div>
  <span class='img-desc'></span>
</div>

<div class="intro-header no-img">
  <div class="container-md">
    <div class="row">
      <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
        <div class="post-heading">
          <h1>State Machine Compiler - Rust Macros</h1>
          
            
              <h2 class="post-subheading">Generating code via macros</h2>
            
          

          
            <span class="post-meta">Posted on May 5, 2024</span>
            
            
              <!--- "ReadTime on GitHub Jekyll" (c) 2020 Ruby Griffith Ramirez, MIT License -->






  
  <span class="post-meta"><span class="d-none d-md-inline middot">&middot;</span> 13 minute read</span>


            
          
        </div>
      </div>
    </div>
  </div>
</div>
</header>





<div class=" container-md ">
  <div class="row">
    <div class=" col-xl-8 offset-xl-2 col-lg-10 offset-lg-1 ">

      

      

      <article role="main" class="blog-post">
        <p>In thisIn this series of posts, we will create a very simple language that can
be used to specify a state machine. Then we will write a compiler that will
translate the description to a code that can simulate this state machine.</p>

<p>Here is the agenda:<br />
<a href="../2024-05-03-State-Machine-Compiler-Intro">Part 1</a>: What is a state machine? A (Rust) program to simulate state machine.<br />
<a href="../2024-05-05-state-machine-compiler-rust-macros">Part 2</a>: Writing (Rust) macros to reduce repetition<br />
<a href="../2024-05-07-state-machine-compiler-a-small-language">Part 3</a>: A small language and convert a description into a high level language(Rust) implementation<br />
Proposed Part 4: Translating the description into a lower level
assembly like language(LLVM IR)
sembly like language(LLVM IR)</p>

<p>This is part 2.</p>

<h2 id="background">Background</h2>

<p>In the <a href="../2024-05-03-State-Machine-Compiler-Intro">previous post</a>,
we ended up with a rust implementation of state machine simulation.
We also concluded that in order to test different state machine, we
would like a better way, as writing full code involves a lot of
boilerplate.</p>

<p><a href="https://doc.rust-lang.org/book/ch19-06-macros.html">Rust Macros</a> allow us to generate rust code by
parsing patterns and using them at appropriate places.</p>

<h2 id="structure">Structure</h2>
<p>Our code can be divided into two parts:</p>

<ol>
  <li>
    <p>Declarations
a. States
b. Symbols
c. Tape machine specification</p>
  </li>
  <li>
    <p>Simulation
a. Given the tape machine state and tape head content, we
perform the associated actions and transition to next
state. We perform this for required number of steps.</p>
  </li>
</ol>

<p>Let’s take a looks at declarations first.</p>

<h2 id="declarations">Declarations</h2>

<p>Following is the declaration of states:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq)]</span>
<span class="k">enum</span> <span class="n">TapeMachineState</span> <span class="p">{</span>
    <span class="n">b</span><span class="p">,</span>
    <span class="n">o</span><span class="p">,</span>
    <span class="n">q</span><span class="p">,</span>
    <span class="n">p</span><span class="p">,</span>
    <span class="n">f</span><span class="p">,</span>
<span class="p">}</span></code></pre></figure>

<p>If we had to write the same code for a different state machine,
say with states, a, b, c, d, then we will write:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq)]</span>
<span class="k">enum</span> <span class="n">TapeMachineState</span> <span class="p">{</span>
    <span class="n">a</span><span class="p">,</span>
    <span class="n">b</span><span class="p">,</span>
    <span class="n">c</span><span class="p">,</span>
    <span class="n">d</span><span class="p">,</span>
<span class="p">}</span></code></pre></figure>

<p>Since only the inner contents of the enum are changing, it would
be great if we could have something like this:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">states!</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span></code></pre></figure>

<p>Rust macros does exactly this, with a little different syntax:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">states!</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>

<span class="c">// Generates the following code:</span>
<span class="c">// #[derive(Debug, PartialEq, Eq)]</span>
<span class="c">// enum TapeMachineState {</span>
<span class="c">//     a,</span>
<span class="c">//     b,</span>
<span class="c">//     c,</span>
<span class="c">//     d,</span>
<span class="c">// }</span></code></pre></figure>

<p>Let me present the macro definition and then i can explain how it works.</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">macro_rules!</span> <span class="n">states</span> <span class="p">{</span>
    <span class="p">(</span> <span class="nv">$</span><span class="p">(</span> <span class="nv">$x:ident</span> <span class="p">),</span><span class="o">*</span> <span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq)]</span>
        <span class="k">enum</span> <span class="n">TapeMachineState</span> <span class="p">{</span>
            <span class="nv">$</span><span class="p">(</span> <span class="nv">$x</span> <span class="p">),</span><span class="o">*</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span></code></pre></figure>

<p>Lets break it down:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">macro_rules!</code> is a macro definition. It takes a name and a body.</li>
  <li><code class="language-plaintext highlighter-rouge">states</code> is the name of the macro.</li>
  <li><code class="language-plaintext highlighter-rouge">( $( $x:ident ),* )</code> is the pattern. This is what macro will consume. Lets simplify it:
a. If remove <code class="language-plaintext highlighter-rouge">$</code> and <code class="language-plaintext highlighter-rouge">ident</code> etc., we will end up with
<code class="language-plaintext highlighter-rouge">(x),*</code>. This will expand to <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">x</code> and so on.
Rust will try to match the pattern with the input, and store the
matched values in the <code class="language-plaintext highlighter-rouge">$x</code> variables. <code class="language-plaintext highlighter-rouge">ident</code> means the values
should be identifiers. We can ignore it for now.</li>
  <li><code class="language-plaintext highlighter-rouge">#[derive(Debug, PartialEq, Eq)]</code> is the body of the macro. It will be output as
it is.</li>
  <li>Similarly, <code class="language-plaintext highlighter-rouge">enum TapeMachineState {</code></li>
  <li>Now we end up with:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                    $(
                        $x,
                    )*
</code></pre></div></div>

<p>This means for all the values stored in <code class="language-plaintext highlighter-rouge">x</code>, concatenate them
with <code class="language-plaintext highlighter-rouge">,</code> and then output them.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">}</code> is the end of the body.</li>
</ol>

<p>So for our example:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">x</code> will be <code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>, <code class="language-plaintext highlighter-rouge">c</code>, <code class="language-plaintext highlighter-rouge">d</code></li>
  <li>On expanding the body <code class="language-plaintext highlighter-rouge">$($x),*</code>, we will get: <code class="language-plaintext highlighter-rouge">a, b, c, d</code></li>
  <li>The whole body will be:</li>
</ol>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq)]</span>
<span class="k">enum</span> <span class="n">TapeMachineState</span> <span class="p">{</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span>
<span class="p">}</span></code></pre></figure>

<p>Exactly what we wanted.</p>

<p>Let’s look at symbol declarations:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq,</span> <span class="nd">Clone)]</span>
<span class="k">enum</span> <span class="n">TapeMachineSymbol</span> <span class="p">{</span>
 <span class="n">Symbol0</span><span class="p">,</span>
 <span class="n">Symbol1</span><span class="p">,</span>
 <span class="n">Symbole</span><span class="p">,</span>
 <span class="n">Symbolx</span><span class="p">,</span>
 <span class="n">SymbolX</span><span class="p">,</span>
<span class="p">}</span></code></pre></figure>

<p>We will want a macro like this:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">symbols!</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">X</span><span class="p">);</span>

<span class="c">// Generates the following code:</span>
<span class="c">// FIXME: this generates `SymbolZero` not `Symbol0`</span>
<span class="c">// #[derive(Debug, PartialEq, Eq, Clone)]</span>
<span class="c">// enum TapeMachineSymbol {</span>
<span class="c">//     Symbol0,</span>
<span class="c">//     Symbol1,</span>
<span class="c">//     Symbole,</span>
<span class="c">//     Symbolx,</span>
<span class="c">//     SymbolX,</span>
<span class="c">// }</span></code></pre></figure>

<p>Following similar logic, we can define the macro as:</p>

<p>[Clarify the <code class="language-plaintext highlighter-rouge">B</code>, <code class="language-plaintext highlighter-rouge">E</code>, <code class="language-plaintext highlighter-rouge">A</code> symbols. We dont need them actually.]</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">macro_rules!</span> <span class="n">symbols</span> <span class="p">{</span>
 <span class="p">(</span> <span class="nv">$</span><span class="p">(</span> <span class="nv">$x:ident</span> <span class="p">),</span><span class="o">*</span> <span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
     <span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq,</span> <span class="nd">Clone)]</span>
     <span class="k">enum</span> <span class="n">TapeMachineSymbol</span> <span class="p">{</span>
         <span class="nv">$</span><span class="p">(</span>
             <span class="n">Symbol</span><span class="nv">$x</span><span class="p">,</span>
         <span class="p">)</span><span class="o">*</span>
         <span class="n">B</span><span class="p">,</span>
         <span class="n">E</span><span class="p">,</span>
         <span class="n">A</span><span class="p">,</span>
     <span class="p">}</span>
 <span class="p">};</span>
<span class="p">}</span></code></pre></figure>

<p>However in our initial implementation, we also wanted support
for printing the symbols.
Here is the code that we used:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span> <span class="n">TapeMachineSymbol</span> <span class="p">{</span>
 <span class="k">fn</span> <span class="nf">as_str</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'static</span> <span class="nb">str</span> <span class="p">{</span>
     <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
         <span class="nn">TapeMachineSymbol</span><span class="p">::</span><span class="n">Symbol0</span> <span class="k">=&gt;</span> <span class="s">"0"</span><span class="p">,</span>
         <span class="nn">TapeMachineSymbol</span><span class="p">::</span><span class="n">Symbol1</span> <span class="k">=&gt;</span> <span class="s">"1"</span><span class="p">,</span>
         <span class="nn">TapeMachineSymbol</span><span class="p">::</span><span class="n">Symbole</span> <span class="k">=&gt;</span> <span class="s">"e"</span><span class="p">,</span>
         <span class="nn">TapeMachineSymbol</span><span class="p">::</span><span class="n">Symbolx</span> <span class="k">=&gt;</span> <span class="s">"x"</span><span class="p">,</span>
         <span class="nn">TapeMachineSymbol</span><span class="p">::</span><span class="n">SymbolX</span> <span class="k">=&gt;</span> <span class="s">"X"</span>
     <span class="p">}</span>
 <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>We would like to generate this as well. That means we will need
to take the value to be printed with each symbol. A macro like
following will do the job:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">symbols!</span><span class="p">((</span><span class="n">Zero</span><span class="p">,</span> <span class="s">"0"</span><span class="p">),</span> <span class="p">(</span><span class="n">One</span><span class="p">,</span> <span class="s">"1"</span><span class="p">),</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="s">"x"</span><span class="p">));</span>

<span class="c">// Generates the following code:</span>
<span class="c">// #[derive(Debug, PartialEq, Eq, Clone)]</span>
<span class="c">// enum TapeMachineSymbol {</span>
<span class="c">//     Symbol0,</span>
<span class="c">//     Symbol1,</span>
<span class="c">//     Symbole,</span>
<span class="c">//     Symbolx,</span>
<span class="c">//     SymbolX,</span>
<span class="c">// }</span>
<span class="c">// impl TapeMachineSymbol {</span>
<span class="c">//     fn as_str(&amp;self) -&gt; &amp;'static str {</span>
<span class="c">//         match self {</span>
<span class="c">//             TapeMachineSymbol::Symbol0 =&gt; "0",</span>
<span class="c">//             TapeMachineSymbol::Symbol1 =&gt; "1",</span>
<span class="c">//             TapeMachineSymbol::Symbole =&gt; "e",</span>
<span class="c">//             TapeMachineSymbol::Symbolx =&gt; "x",</span>
<span class="c">//             TapeMachineSymbol::SymbolX =&gt; "X"</span>
<span class="c">//         }</span>
<span class="c">//     }</span>
<span class="c">// }</span></code></pre></figure>

<p>Here is the modified macro:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">macro_rules!</span> <span class="n">symbols</span> <span class="p">{</span>
 <span class="p">(</span> <span class="nv">$</span><span class="p">(</span> <span class="p">(</span><span class="nv">$x:ident</span><span class="p">,</span> <span class="nv">$y:literal</span><span class="p">)</span> <span class="p">),</span><span class="o">*</span> <span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
     <span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq,</span> <span class="nd">Clone)]</span>
     <span class="k">enum</span> <span class="n">TapeMachineSymbol</span> <span class="p">{</span>
         <span class="nv">$</span><span class="p">(</span>
             <span class="nv">$x</span><span class="p">,</span>
         <span class="p">)</span><span class="o">*</span>
         <span class="n">B</span><span class="p">,</span>
         <span class="n">E</span><span class="p">,</span>
         <span class="n">A</span><span class="p">,</span>
     <span class="p">}</span>

     <span class="k">impl</span> <span class="n">TapeMachineSymbol</span> <span class="p">{</span>
         <span class="k">fn</span> <span class="nf">as_str</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'static</span> <span class="nb">str</span> <span class="p">{</span>
             <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
                 <span class="nv">$</span><span class="p">(</span>
                     <span class="nn">TapeMachineSymbol</span><span class="p">::</span><span class="nv">$x</span> <span class="k">=&gt;</span> <span class="nv">$y</span><span class="p">,</span>
                 <span class="p">)</span><span class="o">*</span>
                 <span class="nn">TapeMachineSymbol</span><span class="p">::</span><span class="n">B</span> <span class="k">=&gt;</span> <span class="s">""</span><span class="p">,</span>
                 <span class="nn">TapeMachineSymbol</span><span class="p">::</span><span class="n">E</span> <span class="k">=&gt;</span> <span class="s">""</span><span class="p">,</span>
                 <span class="nn">TapeMachineSymbol</span><span class="p">::</span><span class="n">A</span> <span class="k">=&gt;</span> <span class="s">"*"</span><span class="p">,</span>
             <span class="p">}</span>
         <span class="p">}</span>
     <span class="p">}</span>
 <span class="p">};</span>
<span class="p">}</span></code></pre></figure>

<p>The only different is following line:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>( $(($x: ident, $y: literal)),* )

</code></pre></div></div>

<p>This pattern will match the input so that <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> contain the
symbol name and the value to be printed in pair.</p>

<p>For example, following line will specify the different
values to be printed for different symbols:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
                    $(
                        TapeMachineSymbol::$x =&gt; $y,
                    )*

</code></pre></div></div>

<p>What remains in the declaration is tape machine declaration, i.e.</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="n">TapeMachine</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">state</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">TapeMachineState</span><span class="p">,</span>
    <span class="n">result</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">TapeMachineSymbol</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">index</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">TapeMachine</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">state</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">TapeMachineState</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">TapeMachineSymbol</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
        <span class="n">Self</span> <span class="p">{</span>
            <span class="n">state</span><span class="p">,</span>
            <span class="n">result</span><span class="p">,</span>
            <span class="n">index</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">p</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">symbol</span><span class="p">:</span> <span class="n">TapeMachineSymbol</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.result</span><span class="p">[</span><span class="k">self</span><span class="py">.index</span><span class="p">]</span> <span class="o">=</span> <span class="n">symbol</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">r</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.index</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">l</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.index</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Notice how this specification doesnt vary with the symbols and
state machine used. We can have a very simple macro like this:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">macro_rules!</span> <span class="n">init_tape</span> <span class="p">{</span>
    <span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nd">#[derive(Debug)]</span>
        <span class="k">struct</span> <span class="n">TapeMachine</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="n">state</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">TapeMachineState</span><span class="p">,</span>
            <span class="n">result</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">TapeMachineSymbol</span><span class="o">&gt;</span><span class="p">,</span>
            <span class="n">index</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">TapeMachine</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span>
                <span class="n">state</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">TapeMachineState</span><span class="p">,</span>
                <span class="n">result</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">TapeMachineSymbol</span><span class="o">&gt;</span><span class="p">,</span>
            <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">TapeMachine</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">TapeMachine</span> <span class="p">{</span>
                    <span class="n">state</span><span class="p">,</span>
                    <span class="n">result</span><span class="p">,</span>
                    <span class="n">index</span><span class="p">:</span> <span class="mi">0u</span><span class="n">size</span><span class="p">,</span>
                <span class="p">};</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">fn</span> <span class="n">p</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">TapeMachineSymbol</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">vec</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="o">&amp;</span><span class="nv">'a</span> <span class="n">TapeMachineSymbol</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">vec</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">fn</span> <span class="nf">r</span><span class="p">(</span><span class="n">index</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">*</span><span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">fn</span> <span class="nf">l</span><span class="p">(</span><span class="n">index</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">*</span><span class="n">index</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span></code></pre></figure>

<p>[TODO - Highlight that this macro can be used only after the declaration of the enums and discuss if there is a better way to do it]</p>

<p>Invoking the macro will simply generate the code for the
tape machine implementation:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">init_tape!</span><span class="p">();</span></code></pre></figure>

<p>To summarize, If we have following tape machine:</p>

<ol>
  <li>States: a, b, c, d</li>
  <li>Symbols: 0, 1, 2, 3, 4</li>
</ol>

<p>We can generate the declarations using the following code:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">states!</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
<span class="nd">symbols!</span><span class="p">((</span><span class="n">Zero</span><span class="p">,</span> <span class="s">"0"</span><span class="p">),</span> <span class="p">(</span><span class="n">One</span><span class="p">,</span> <span class="s">"1"</span><span class="p">),</span> <span class="p">(</span><span class="n">Two</span><span class="p">,</span> <span class="s">"2"</span><span class="p">),</span> <span class="p">(</span><span class="n">Three</span><span class="p">,</span> <span class="s">"3"</span><span class="p">),</span> <span class="p">(</span><span class="n">Four</span><span class="p">,</span> <span class="s">"4"</span><span class="p">));</span>
<span class="nd">init_tape!</span><span class="p">();</span></code></pre></figure>

<p>Let’s move on to the simulation part.</p>

<h2 id="simulation">Simulation</h2>

<p>Here is the crux of the simulation:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">steps</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span>
        <span class="s">"Step: {} State: {:?} Symbol: {:?}"</span><span class="p">,</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">tape_machine</span><span class="py">.state</span><span class="p">,</span> <span class="n">tape_machine</span><span class="py">.result</span><span class="p">[</span><span class="n">tape_machine</span><span class="py">.index</span><span class="p">]</span>
    <span class="p">);</span>

    <span class="k">match</span> <span class="p">(</span><span class="n">tape_machine</span><span class="py">.state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tape_machine</span><span class="py">.result</span><span class="p">[</span><span class="n">tape_machine</span><span class="py">.index</span><span class="p">])</span> <span class="p">{</span>
        <span class="p">(</span><span class="nn">TapeMachineState</span><span class="p">::</span><span class="n">o</span><span class="p">,</span> <span class="nn">TapeMachineSymbol</span><span class="p">::</span><span class="n">Symbol1</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="n">tape_machine</span><span class="nf">.r</span><span class="p">();</span>
            <span class="n">tape_machine</span><span class="nf">.p</span><span class="p">(</span><span class="nn">TapeMachineSymbol</span><span class="p">::</span><span class="n">Symbolx</span><span class="p">);</span>
            <span class="n">tape_machine</span><span class="nf">.l</span><span class="p">();</span>
            <span class="n">tape_machine</span><span class="nf">.l</span><span class="p">();</span>
            <span class="n">tape_machine</span><span class="nf">.l</span><span class="p">();</span>
            <span class="n">tape_machine</span><span class="py">.state</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nn">TapeMachineState</span><span class="p">::</span><span class="n">o</span><span class="p">;</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Final State: {:?}"</span><span class="p">,</span> <span class="nn">TapeMachineState</span><span class="p">::</span><span class="n">o</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="p">(</span><span class="nn">TapeMachineState</span><span class="p">::</span><span class="n">o</span><span class="p">,</span> <span class="nn">TapeMachineSymbol</span><span class="p">::</span><span class="n">Symbol0</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="c">// X means do nothing</span>
            <span class="n">tape_machine</span><span class="py">.state</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nn">TapeMachineState</span><span class="p">::</span><span class="n">q</span><span class="p">;</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Final State: {:?}"</span><span class="p">,</span> <span class="nn">TapeMachineState</span><span class="p">::</span><span class="n">q</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c">// ... more rules</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Let’s break down the structure:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">for i in 0..steps</code> is the loop that will run for required</li>
  <li><code class="language-plaintext highlighter-rouge">println!</code> is the print statement</li>
  <li>Match statement is simply conditioning on the current state and
the current symbol.</li>
  <li>We perform the actions depending on the current state and symbol.</li>
  <li>We update the state and print the final state.</li>
  <li>We loop again.</li>
</ol>

<p>If we can generate the code for one branch like this:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="p">(</span><span class="nn">TapeMachineState</span><span class="p">::</span><span class="n">o</span><span class="p">,</span> <span class="nn">TapeMachineSymbol</span><span class="p">::</span><span class="n">Symbol1</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
    <span class="n">tape_machine</span><span class="nf">.r</span><span class="p">();</span>
    <span class="n">tape_machine</span><span class="nf">.p</span><span class="p">(</span><span class="nn">TapeMachineSymbol</span><span class="p">::</span><span class="n">Symbolx</span><span class="p">);</span>
    <span class="n">tape_machine</span><span class="nf">.l</span><span class="p">();</span>
    <span class="n">tape_machine</span><span class="nf">.l</span><span class="p">();</span>
    <span class="n">tape_machine</span><span class="nf">.l</span><span class="p">();</span>
    <span class="n">tape_machine</span><span class="py">.state</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nn">TapeMachineState</span><span class="p">::</span><span class="n">o</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Final State: {:?}"</span><span class="p">,</span> <span class="nn">TapeMachineState</span><span class="p">::</span><span class="n">o</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>then we can just do <code class="language-plaintext highlighter-rouge">$(code generation logic for one rule)*</code> in our
macro.</p>

<p>Let’s focus on a single rule for now. Here are the things we need:</p>

<ol>
  <li>The state</li>
  <li>The symbol</li>
  <li>The actions in order. If its a print statement then value to be
printed is the symbol.</li>
  <li>The next state</li>
</ol>

<p>I propose the following macro:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">handle_rule!</span><span class="p">([</span><span class="n">O</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">R</span><span class="p">,</span> <span class="nf">P</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">L</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">L</span><span class="p">],</span> <span class="p">[</span><span class="n">O</span><span class="p">]);</span>
<span class="c">// [state], [symbol], [actions], [next state]</span></code></pre></figure>

<p>Here is how this will look like in actual implementation:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>([$state: ident], [$($condition: ident)|+], [$($action: expr),*], [$final_state: ident])

</code></pre></div></div>

<p>Let’s break it down:</p>

<ol>
  <li>States: <code class="language-plaintext highlighter-rouge">[$state: ident]</code></li>
  <li>Symbols: <code class="language-plaintext highlighter-rouge">[$($condition: ident)|+]</code> : One or more coditions</li>
  <li>Actions: <code class="language-plaintext highlighter-rouge">[$($action: expr),*]</code> : One or more actions</li>
  <li>Final state: <code class="language-plaintext highlighter-rouge">[$final_state: ident]</code></li>
</ol>

<p>All of them comma separated.</p>

<p>Now because there are going to be multiple rules, we will just do
<code class="language-plaintext highlighter-rouge">$(rule)*</code> to match all the rules.</p>

<p>i.e.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$([$state: ident], [$($condition: ident)|+], [$($action: expr),*], [$final_state: ident])*

</code></pre></div></div>

<p>However there is a slight problem with this. There is no way to know
when a rule ends and when another rule starts. [ Clarify why we can’t just use <code class="language-plaintext highlighter-rouge">;</code> ].</p>

<p>Let’s settle on specifying multiple rules like this:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="p">{[</span><span class="n">O</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">R</span><span class="p">,</span> <span class="nf">P</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">L</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">L</span><span class="p">],</span> <span class="p">[</span><span class="n">O</span><span class="p">]},</span>
<span class="p">{[</span><span class="n">O</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">R</span><span class="p">],</span> <span class="p">[</span><span class="n">q</span><span class="p">]}</span>
<span class="o">...</span></code></pre></figure>

<p>i.e. each rule is wrapped up in curly braces, separated by comma.</p>

<p>So our new macro will be something like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$({ handle_rule },*)
</code></pre></div></div>

<p>Here is how it will look like in actual implementation:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$({ [$state: ident], [$($condition: ident)|+], [$($action: expr),*], [$final_state: ident] } ),*

// Break it down like this:
// handle_rule = [$state: ident], [$($condition: ident)|+], [$($action: expr),*], [$final_state: ident]
// Full rule = $({ handle_rule }),*


</code></pre></div></div>

<p>Since the patterns are hard to read, visualize what the pattern
will allow us to do: It will parse the input and give us a list of rules. Each rule will have its state, symbol, actions and next state
stored in the corresponding variables.</p>

<p>Now the only different with the macros is that you cannot access the
list content by index. You will have to specify another pattern
which takes the elements of the list one by one and generates the
output sequence.</p>

<p>So to summarise:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Raw</span> <span class="n">text</span> <span class="k">-&gt;</span> <span class="n">Pattern</span> <span class="n">to</span> <span class="n">Match</span> <span class="k">-&gt;</span> <span class="n">Parsed</span> <span class="n">Sequence</span> <span class="k">-&gt;</span> <span class="n">Pattern</span> <span class="n">to</span> <span class="n">Generate</span> <span class="k">-&gt;</span> <span class="n">Generated</span> <span class="n">code</span>
</code></pre></div></div>

<p>We can also work with lists of lists, with same restriction: No indexing, only output pattern. [ Clarify how index can be passed, but again with complications]</p>

<p>With this in mind, let me present the final macro:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">macro_rules!</span> <span class="n">transition_rules</span> <span class="p">{</span>
   <span class="p">(</span><span class="nv">$tape_machine</span><span class="p">:</span> <span class="n">ident</span><span class="p">,</span> <span class="nv">$steps</span><span class="p">:</span> <span class="n">ident</span><span class="p">,</span> <span class="nv">$</span><span class="p">({</span> <span class="p">[</span><span class="nv">$state</span><span class="p">:</span> <span class="n">ident</span><span class="p">],</span> <span class="p">[</span><span class="nv">$</span><span class="p">(</span><span class="nv">$condition</span><span class="p">:</span> <span class="n">ident</span><span class="p">)|</span><span class="o">+</span><span class="p">],</span> <span class="p">[</span><span class="nv">$</span><span class="p">(</span><span class="nv">$action</span><span class="p">:</span> <span class="n">expr</span><span class="p">),</span><span class="o">*</span><span class="p">],</span> <span class="p">[</span><span class="nv">$final_state</span><span class="p">:</span> <span class="n">ident</span><span class="p">]</span> <span class="p">}</span> <span class="p">),</span><span class="o">*</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
       <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="nv">$steps</span> <span class="p">{</span>
           <span class="nd">println!</span><span class="p">(</span>
               <span class="s">"Step: {} State: {:?} Symbol: {:?}"</span><span class="p">,</span>
               <span class="n">i</span><span class="p">,</span> <span class="nv">$tape_machine</span><span class="py">.state</span><span class="p">,</span> <span class="nv">$tape_machine</span><span class="py">.result</span><span class="p">[</span><span class="nv">$tape_machine</span><span class="py">.index</span><span class="p">]</span>
           <span class="p">);</span>
           <span class="k">match</span> <span class="p">(</span><span class="nv">$tape_machine</span><span class="py">.state</span><span class="p">,</span> <span class="nv">$tape_machine</span><span class="py">.result</span><span class="p">[</span><span class="nv">$tape_machine</span><span class="py">.index</span><span class="p">])</span> <span class="p">{</span>
               <span class="nv">$</span><span class="p">(</span>
                   <span class="p">(</span><span class="nn">TapeMachineState</span><span class="p">::</span><span class="nv">$state</span><span class="p">,</span>
                       <span class="nv">$</span><span class="p">(</span>
                           <span class="nd">process_action!</span><span class="p">(</span><span class="nv">$condition</span><span class="p">)</span>
                       <span class="p">)|</span><span class="o">*</span>
                   <span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                       <span class="nv">$</span><span class="p">(</span>
                           <span class="nv">$action</span><span class="p">;</span>
                       <span class="p">)</span><span class="o">*</span>
                       <span class="nv">$tape_machine</span><span class="py">.state</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nn">TapeMachineState</span><span class="p">::</span><span class="nv">$final_state</span><span class="p">;</span>
                       <span class="nd">println!</span><span class="p">(</span><span class="s">"Final State: {:?}"</span><span class="p">,</span> <span class="nn">TapeMachineState</span><span class="p">::</span><span class="nv">$final_state</span><span class="p">);</span>
                   <span class="p">}</span>
               <span class="p">)</span><span class="o">*</span>
               <span class="p">(</span><span class="mi">_</span><span class="p">,</span> <span class="mi">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                   <span class="nd">println!</span><span class="p">(</span>
                       <span class="s">"{:?} {:?}"</span><span class="p">,</span>
                       <span class="nv">$tape_machine</span><span class="py">.state</span><span class="p">,</span> <span class="nv">$tape_machine</span><span class="py">.result</span><span class="p">[</span><span class="nv">$tape_machine</span><span class="py">.index</span><span class="p">]</span>
                   <span class="p">);</span>
                   <span class="nd">panic!</span><span class="p">(</span><span class="s">"Invalid state reached"</span><span class="p">);</span>
               <span class="p">}</span>
           <span class="p">}</span>
       <span class="p">}</span>
   <span class="p">};</span>
<span class="p">}</span></code></pre></figure>

<p>Notice the two levels of repetition:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$(                                  // First level repetition starts
    (TapeMachineState::$state,
        $(
            process_action!($condition)
        )|*                         // Second level repetition 1
    ) =&gt; {
        $(
            $action;
        )*                          // Second level repetition 2
        $tape_machine.state = &amp;TapeMachineState::$final_state;
        println!("Final State: {:?}", TapeMachineState::$final_state);
    }
)*                                  // First level repetition ends

</code></pre></div></div>

<ol>
  <li>First level repetitions are corresponding to different rules.</li>
  <li>Second level repetition 1 is for a particular rule, writing
multiple conditions. e.g. <code class="language-plaintext highlighter-rouge">Symbol1 | Symbol0</code>. Notice that we
have used <code class="language-plaintext highlighter-rouge">|</code> to separate the conditions and used another macro
<code class="language-plaintext highlighter-rouge">process_action!</code> to process the actions. This macro is defined
below:</li>
</ol>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">macro_rules!</span> <span class="n">process_action</span> <span class="p">{</span>
    <span class="c">// If the rule states that for any symbol, the action</span>
    <span class="c">// has to be performed then we will use `*` as per</span>
    <span class="c">// rust syntax.</span>
    <span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="mi">_</span>
    <span class="p">};</span>
    <span class="c">// Otherwise simply use the symbol</span>
    <span class="p">(</span><span class="nv">$action</span><span class="p">:</span> <span class="n">ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nn">TapeMachineSymbol</span><span class="p">::</span><span class="nv">$action</span>
    <span class="p">};</span>
<span class="p">}</span></code></pre></figure>

<p>In summary all this trouble just to use <code class="language-plaintext highlighter-rouge">*</code> inside the match statement.</p>

<ol>
  <li>Second level repetition 2 is for a particular rule, writing
multiple actions. e.g. <code class="language-plaintext highlighter-rouge">R, P(x), L, L, L</code> will translate to <code class="language-plaintext highlighter-rouge">R, P(x), L, L, L</code>.</li>
</ol>

<p>But that’s not what we wanted, right? We wanted something like this:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="n">tape_machine</span><span class="nf">.r</span><span class="p">();</span>
<span class="n">tape_machine</span><span class="nf">.p</span><span class="p">(</span><span class="nn">TapeMachineSymbol</span><span class="p">::</span><span class="n">Symbolx</span><span class="p">);</span>
<span class="n">tape_machine</span><span class="nf">.l</span><span class="p">();</span>
<span class="n">tape_machine</span><span class="nf">.l</span><span class="p">();</span>
<span class="n">tape_machine</span><span class="nf">.l</span><span class="p">();</span></code></pre></figure>

<p>How about we define few more macros:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">R!</span><span class="p">()</span>
<span class="nd">P!</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="nd">L!</span><span class="p">()</span>
<span class="nd">L!</span><span class="p">()</span>
<span class="nd">L!</span><span class="p">()</span></code></pre></figure>

<p>These macros can be defined as follows:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">macro_rules!</span> <span class="n">P</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$tape_machine:ident</span><span class="p">,</span> <span class="nv">$symbol:ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nf">p</span><span class="p">(</span>
            <span class="o">&amp;</span><span class="nn">TapeMachineSymbol</span><span class="p">::</span><span class="nv">$symbol</span><span class="p">,</span>
            <span class="nv">$tape_machine</span><span class="py">.index</span><span class="p">,</span>
            <span class="nv">$tape_machine</span><span class="py">.result</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="nd">macro_rules!</span> <span class="n">R</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$tape_machine:ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nf">r</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="nv">$tape_machine</span><span class="py">.index</span><span class="p">)</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="nd">macro_rules!</span> <span class="n">L</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$tape_machine:ident</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="nf">l</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="nv">$tape_machine</span><span class="py">.index</span><span class="p">)</span>
    <span class="p">};</span>
<span class="p">}</span></code></pre></figure>

<p>These macros will perform following actions:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">P!</span><span class="p">(</span><span class="n">tape_machine</span><span class="p">,</span> <span class="n">Symbolx</span><span class="p">);</span> <span class="k">-&gt;</span> <span class="nf">p</span><span class="p">(</span><span class="o">&amp;</span><span class="nn">TapeMachineSymbol</span><span class="p">::</span><span class="n">Symbolx</span><span class="p">,</span> <span class="n">tape_machine</span><span class="py">.index</span><span class="p">,</span> <span class="n">tape_machine</span><span class="py">.result</span><span class="p">);</span>
<span class="nd">L!</span><span class="p">(</span><span class="n">tape_machine</span><span class="p">);</span> <span class="k">-&gt;</span> <span class="nf">l</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">tape_machine</span><span class="py">.index</span><span class="p">);</span>
<span class="nd">R!</span><span class="p">(</span><span class="n">tape_machine</span><span class="p">);</span> <span class="k">-&gt;</span> <span class="nf">r</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">tape_machine</span><span class="py">.index</span><span class="p">);</span></code></pre></figure>

<p>Where these functions have been defined in the declaration section.</p>

<p>A sidenote:
We need to pass <code class="language-plaintext highlighter-rouge">tape_machine</code> and <code class="language-plaintext highlighter-rouge">steps</code> in the <code class="language-plaintext highlighter-rouge">transition_rules!</code> macros. Why? Because we cannot just use
arbitrary variables in macros. Macros can use the variables that are
defined inside the body or the ones that are explicitly passed
to the macro. <a href="https://veykril.github.io/tlborm/decl-macros/minutiae/hygiene.html">Read more about this</a></p>

<p>Alright, now we have all the macros defined, let’s look at the final
program:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c">// Import the macros we defined</span>
<span class="c">// TODO - Modify the code structure so that macros</span>
<span class="c">// are defined in a separate file and can be imported</span>
<span class="nd">states!</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">O</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">F</span><span class="p">);</span>
<span class="nd">symbols!</span><span class="p">((</span><span class="n">Zero</span><span class="p">,</span> <span class="s">"0"</span><span class="p">),</span> <span class="p">(</span><span class="n">One</span><span class="p">,</span> <span class="s">"1"</span><span class="p">),</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="s">"x"</span><span class="p">));</span>
<span class="nd">init_tape!</span><span class="p">();</span>

<span class="c">// To test: rustc +nightly -Zunpretty=expanded src/main.rs</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">max_len</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">steps</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">result</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="n">TapeMachineSymbol</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="o">&amp;</span><span class="nn">TapeMachineSymbol</span><span class="p">::</span><span class="n">B</span><span class="p">;</span> <span class="n">max_len</span><span class="p">];</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">tape_machine</span> <span class="o">=</span> <span class="nn">TapeMachine</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="nn">TapeMachineState</span><span class="p">::</span><span class="n">B</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">result</span><span class="p">);</span>
    <span class="nd">transition_rules!</span><span class="p">(</span>
        <span class="n">tape_machine</span><span class="p">,</span>
        <span class="n">steps</span><span class="p">,</span>
        <span class="p">{</span> <span class="p">[</span><span class="n">B</span><span class="p">],</span> <span class="p">[</span><span class="n">A</span><span class="p">],</span> <span class="p">[</span><span class="nd">P!</span><span class="p">(</span><span class="n">tape_machine</span><span class="p">,</span> <span class="n">E</span><span class="p">),</span> <span class="nd">R!</span><span class="p">(</span><span class="n">tape_machine</span><span class="p">),</span> <span class="nd">P!</span><span class="p">(</span><span class="n">tape_machine</span><span class="p">,</span> <span class="n">E</span><span class="p">),</span> <span class="nd">R!</span><span class="p">(</span><span class="n">tape_machine</span><span class="p">),</span> <span class="nd">P!</span><span class="p">(</span><span class="n">tape_machine</span><span class="p">,</span> <span class="n">Zero</span><span class="p">),</span> <span class="nd">R!</span><span class="p">(</span><span class="n">tape_machine</span><span class="p">),</span> <span class="nd">R!</span><span class="p">(</span><span class="n">tape_machine</span><span class="p">),</span> <span class="nd">P!</span><span class="p">(</span><span class="n">tape_machine</span><span class="p">,</span> <span class="n">Zero</span><span class="p">),</span> <span class="nd">L!</span><span class="p">(</span><span class="n">tape_machine</span><span class="p">),</span> <span class="nd">L!</span><span class="p">(</span><span class="n">tape_machine</span><span class="p">)],</span> <span class="p">[</span><span class="n">O</span><span class="p">]</span> <span class="p">},</span>
        <span class="p">{</span> <span class="p">[</span><span class="n">O</span><span class="p">],</span> <span class="p">[</span><span class="n">One</span><span class="p">],</span> <span class="p">[</span><span class="nd">R!</span><span class="p">(</span><span class="n">tape_machine</span><span class="p">),</span> <span class="nd">P!</span><span class="p">(</span><span class="n">tape_machine</span><span class="p">,</span> <span class="n">X</span><span class="p">),</span> <span class="nd">L!</span><span class="p">(</span><span class="n">tape_machine</span><span class="p">),</span> <span class="nd">L!</span><span class="p">(</span><span class="n">tape_machine</span><span class="p">),</span> <span class="nd">L!</span><span class="p">(</span><span class="n">tape_machine</span><span class="p">)],</span> <span class="p">[</span><span class="n">O</span><span class="p">]</span> <span class="p">},</span>
        <span class="p">{</span> <span class="p">[</span><span class="n">O</span><span class="p">],</span> <span class="p">[</span><span class="n">Zero</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[</span><span class="n">Q</span><span class="p">]</span> <span class="p">},</span>
        <span class="p">{</span> <span class="p">[</span><span class="n">Q</span><span class="p">],</span> <span class="p">[</span><span class="n">Zero</span> <span class="p">|</span> <span class="n">One</span><span class="p">],</span> <span class="p">[</span><span class="nd">R!</span><span class="p">(</span><span class="n">tape_machine</span><span class="p">),</span> <span class="nd">R!</span><span class="p">(</span><span class="n">tape_machine</span><span class="p">)],</span> <span class="p">[</span><span class="n">Q</span><span class="p">]</span> <span class="p">},</span>
        <span class="p">{</span> <span class="p">[</span><span class="n">Q</span><span class="p">],</span> <span class="p">[</span><span class="n">B</span><span class="p">],</span> <span class="p">[</span><span class="nd">P!</span><span class="p">(</span><span class="n">tape_machine</span><span class="p">,</span> <span class="n">One</span><span class="p">),</span> <span class="nd">L!</span><span class="p">(</span><span class="n">tape_machine</span><span class="p">)],</span> <span class="p">[</span><span class="n">P</span><span class="p">]</span> <span class="p">},</span>
        <span class="p">{</span> <span class="p">[</span><span class="n">P</span><span class="p">],</span> <span class="p">[</span><span class="n">X</span><span class="p">],</span> <span class="p">[</span><span class="nd">E!</span><span class="p">(</span><span class="n">tape_machine</span><span class="p">),</span> <span class="nd">R!</span><span class="p">(</span><span class="n">tape_machine</span><span class="p">)],</span> <span class="p">[</span><span class="n">Q</span><span class="p">]</span> <span class="p">},</span>
        <span class="p">{</span> <span class="p">[</span><span class="n">P</span><span class="p">],</span> <span class="p">[</span><span class="n">E</span><span class="p">],</span> <span class="p">[</span><span class="nd">R!</span><span class="p">(</span><span class="n">tape_machine</span><span class="p">)],</span> <span class="p">[</span><span class="n">F</span><span class="p">]</span> <span class="p">},</span>
        <span class="p">{</span> <span class="p">[</span><span class="n">P</span><span class="p">],</span> <span class="p">[</span><span class="n">B</span><span class="p">],</span> <span class="p">[</span><span class="nd">L!</span><span class="p">(</span><span class="n">tape_machine</span><span class="p">),</span> <span class="nd">L!</span><span class="p">(</span><span class="n">tape_machine</span><span class="p">)],</span> <span class="p">[</span><span class="n">P</span><span class="p">]</span> <span class="p">},</span>
        <span class="p">{</span> <span class="p">[</span><span class="n">F</span><span class="p">],</span> <span class="p">[</span><span class="n">B</span><span class="p">],</span> <span class="p">[</span><span class="nd">P!</span><span class="p">(</span><span class="n">tape_machine</span><span class="p">,</span> <span class="n">Zero</span><span class="p">),</span> <span class="nd">L!</span><span class="p">(</span><span class="n">tape_machine</span><span class="p">),</span> <span class="nd">L!</span><span class="p">(</span><span class="n">tape_machine</span><span class="p">)],</span> <span class="p">[</span><span class="n">O</span><span class="p">]</span> <span class="p">},</span>
        <span class="p">{</span> <span class="p">[</span><span class="n">F</span><span class="p">],</span> <span class="p">[</span><span class="n">A</span><span class="p">],</span> <span class="p">[</span><span class="nd">R!</span><span class="p">(</span><span class="n">tape_machine</span><span class="p">),</span> <span class="nd">R!</span><span class="p">(</span><span class="n">tape_machine</span><span class="p">)],</span> <span class="p">[</span><span class="n">F</span><span class="p">]</span> <span class="p">}</span>
    <span class="p">);</span>
    <span class="k">let</span> <span class="n">binary_result</span> <span class="o">=</span> <span class="n">tape_machine</span>
        <span class="py">.result</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="nf">.as_str</span><span class="p">())</span>
        <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="c">// 0010110111011110111110111111011111110111111110111111111</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">binary_result</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Isn’t this pretty concise? For a different state machine:</p>

<table>
  <thead>
    <tr>
      <th>Current State</th>
      <th>Required Current Tape Head Content</th>
      <th>Action</th>
      <th>Next State</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>a</td>
      <td>None</td>
      <td>P(0)</td>
      <td>b</td>
    </tr>
    <tr>
      <td>b</td>
      <td>0</td>
      <td>R-P(1)</td>
      <td>b</td>
    </tr>
    <tr>
      <td>b</td>
      <td>1</td>
      <td>R</td>
      <td>a</td>
    </tr>
  </tbody>
</table>

<p>The program will be:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c">// Copy paste or import the macros we defined</span>
<span class="nd">states!</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="nd">symbols!</span><span class="p">((</span><span class="n">Zero</span><span class="p">,</span> <span class="s">"0"</span><span class="p">),</span> <span class="p">(</span><span class="n">One</span><span class="p">,</span> <span class="s">"1"</span><span class="p">),</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="s">"x"</span><span class="p">));</span>
<span class="nd">init_tape!</span><span class="p">();</span>

<span class="c">// Copy paste or import the transition macros</span>
<span class="c">// [ Need some work, since they cannot be out of order]</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">max_len</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">steps</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">result</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="n">TapeMachineSymbol</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="o">&amp;</span><span class="nn">TapeMachineSymbol</span><span class="p">::</span><span class="n">B</span><span class="p">;</span> <span class="n">max_len</span><span class="p">];</span>
    <span class="c">// A is the initial state</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">tape_machine</span> <span class="o">=</span> <span class="nn">TapeMachine</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="nn">TapeMachineState</span><span class="p">::</span><span class="n">A</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">result</span><span class="p">);</span>
    <span class="nd">transition_rules!</span><span class="p">(</span>
        <span class="n">tape_machine</span><span class="p">,</span>
        <span class="n">steps</span><span class="p">,</span>
        <span class="p">{[</span><span class="n">A</span><span class="p">],</span> <span class="p">[</span><span class="n">A</span><span class="p">],</span> <span class="p">[</span><span class="nd">P!</span><span class="p">(</span><span class="n">tape_machine</span><span class="p">,</span> <span class="n">Zero</span><span class="p">)],[</span><span class="n">B</span><span class="p">]},</span>
        <span class="p">{[</span><span class="n">B</span><span class="p">],</span> <span class="p">[</span><span class="n">Zero</span><span class="p">],</span> <span class="p">[</span><span class="nd">R!</span><span class="p">(</span><span class="n">tape_machine</span><span class="p">),</span> <span class="nd">P!</span><span class="p">(</span><span class="n">tape_machine</span><span class="p">,</span> <span class="n">One</span><span class="p">)],</span> <span class="p">[</span><span class="n">B</span><span class="p">]},</span>
        <span class="p">{[</span><span class="n">B</span><span class="p">],</span> <span class="p">[</span><span class="n">One</span><span class="p">],</span> <span class="p">[</span><span class="nd">R!</span><span class="p">(</span><span class="n">tape_machine</span><span class="p">)],</span> <span class="p">[</span><span class="n">A</span><span class="p">]}</span>
    <span class="p">);</span>

    <span class="k">let</span> <span class="n">binary_result</span> <span class="o">=</span> <span class="n">tape_machine</span>
        <span class="py">.result</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="nf">.as_str</span><span class="p">())</span>
        <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="c">// 010101..</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">binary_result</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Well, now we are in a much better state. Instead of having to
write the same code for a different state machine, we can
just specify the states, symbols and rules and we are done.</p>

<p>We are done for practical purposes, however the syntax is a little
bit verbose.
Can we specify the states, symbols and rules in a more concise way?
How about this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>STATES: [b], o, q, p, f

SYMBOLS: 0, 1, e, x

TRANSITIONS:
b, *, P(e)-R-P(e)-R-P(0)-R-R-P(0)-L-L, o
o, 1, R-P(x)-L-L-L, o
o, 0, X, q
q, 0 | 1, R-R, q
q, X, P(1)-L, p
p, x, P(X)-R, q
p, e, R, f
p, X, L-L, p
f, *, R-R, f
f, X, P(0)-L-L, o

</code></pre></div></div>

<p>This is the most concise we will every get (may replacing L-L-L with 3L, but ignore that for now).</p>

<p>Can we parse this and generate the code from scratch?
That is the topic of the next post.</p>

      </article>

      

      

      
        <!-- Check if any share-links are active -->




<section id = "social-share-section">
  <span class="sr-only">Share: </span>

  
    <a href="https://twitter.com/intent/tweet?text=State+Machine+Compiler+-+Rust+Macros&url=http%3A%2F%2Flocalhost%3A4000%2F2024-05-05-state-machine-compiler-rust-macros%2F"
      class="btn btn-social-icon btn-twitter" title="Share on Twitter">
      <span class="fab fa-fw fa-twitter" aria-hidden="true"></span>
      <span class="sr-only">Twitter</span>
    </a>
  

  
    <a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Flocalhost%3A4000%2F2024-05-05-state-machine-compiler-rust-macros%2F"
      class="btn btn-social-icon btn-facebook" title="Share on Facebook">
      <span class="fab fa-fw fa-facebook" aria-hidden="true"></span>
      <span class="sr-only">Facebook</span>
    </a>
  

  
    <a href="https://www.linkedin.com/shareArticle?mini=true&url=http%3A%2F%2Flocalhost%3A4000%2F2024-05-05-state-machine-compiler-rust-macros%2F"
      class="btn btn-social-icon btn-linkedin" title="Share on LinkedIn">
      <span class="fab fa-fw fa-linkedin" aria-hidden="true"></span>
      <span class="sr-only">LinkedIn</span>
    </a>
  

  

</section>



      

      <ul class="pagination blog-pager">
        
        <li class="page-item previous">
          <a class="page-link" href="/2024-05-03-State-Machine-Compiler-Intro/" data-toggle="tooltip" data-placement="top" title="State Machine Compiler - Intro">&larr; Previous Post</a>
        </li>
        
        
        <li class="page-item next">
          <a class="page-link" href="/2024-05-07-state-machine-compiler-a-small-language/" data-toggle="tooltip" data-placement="top" title="State Machine Compiler - A Small Language">Next Post &rarr;</a>
        </li>
        
      </ul>
      
  <div class="disqus-comments">
  <div class="comments">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
	  var disqus_shortname = 'mabhay3420-github-io';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</div>
  
  

  




    </div>
  </div>
</div>


  <footer>
  <div class="container-md beautiful-jekyll-footer">
    <div class="row">
      <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
      <ul class="list-inline text-center footer-links"><li class="list-inline-item">
    <a href="mailto:abhaymishra3420@gmail.com" title="Email me">
      <span class="fa-stack fa-lg" aria-hidden="true">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
      </span>
      <span class="sr-only">Email me</span>
   </a>
  </li><li class="list-inline-item">
    <a href="https://www.facebook.com/invictusabhay" title="Facebook">
      <span class="fa-stack fa-lg" aria-hidden="true">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fab fa-facebook fa-stack-1x fa-inverse"></i>
      </span>
      <span class="sr-only">Facebook</span>
   </a>
  </li><li class="list-inline-item">
    <a href="https://github.com/mabhay3420" title="GitHub">
      <span class="fa-stack fa-lg" aria-hidden="true">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fab fa-github fa-stack-1x fa-inverse"></i>
      </span>
      <span class="sr-only">GitHub</span>
   </a>
  </li></ul>

      
      <p class="copyright text-muted">
      
        Abhay mishra
        &nbsp;&bull;&nbsp;
      
      2024

      
        &nbsp;&bull;&nbsp;
        <span class="author-site">
          <a href="http://localhost:4000/">INVICTUS</a>
        </span>
      

      
      </p>
      <p class="theme-by text-muted">
        Powered by
        <a href="https://beautifuljekyll.com">Beautiful Jekyll</a>
      </p>
      </div>
    </div>
  </div>
</footer>


  
  
    
  <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" crossorigin="anonymous"></script>


  
    
  <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>


  
    
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>


  



  
    <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
    
      <script src="/assets/js/beautifuljekyll.js"></script>
    
  









</body>
</html>
