<!DOCTYPE html>
<html lang="en">
<!-- Beautiful Jekyll 5.0.0 | Copyright Dean Attali 2020 -->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  

  

  <title>State Machine Compiler - A Small Language</title>

  
  <meta name="author" content="Abhay mishra">
  

  <meta name="description" content="Generating Rust code from minimal specification">

  

  
  <meta name="keywords" content="deep-learning,Machine Learning, Web Developement, Tech Blog, Compilers">
  

  <link rel="alternate" type="application/rss+xml" title="Abhay's Blog" href="http://localhost:4000/feed.xml">

  

  

  


  
    
      
  <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">


    
      
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css">


    
      
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic">


    
      
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800">


    
  

  
    
      <link rel="stylesheet" href="/assets/css/bootstrap-social.css">
    
      <link rel="stylesheet" href="/assets/css/beautifuljekyll.css">
    
  

  

  
  
  

  

  
  <meta property="og:site_name" content="Abhay's Blog">
  <meta property="og:title" content="State Machine Compiler - A Small Language">
  <meta property="og:description" content="Generating Rust code from minimal specification">

  
  <meta property="og:image" content="https://source.unsplash.com/featured/1920x1080/">
  

  
  <meta property="og:type" content="article">
  <meta property="og:article:author" content="Abhay mishra">
  <meta property="og:article:published_time" content="2024-05-07T00:00:00+05:30">
  <meta property="og:url" content="http://localhost:4000/2024-05-07-state-machine-compiler-a-small-language/">
  <link rel="canonical" href="http://localhost:4000/2024-05-07-state-machine-compiler-a-small-language/">
  

  
  <meta name="twitter:card" content="summary_large_image">
  
  <meta name="twitter:site" content="@">
  <meta name="twitter:creator" content="@">

  <meta property="twitter:title" content="State Machine Compiler - A Small Language">
  <meta property="twitter:description" content="Generating Rust code from minimal specification">

  
  <meta name="twitter:image" content="https://source.unsplash.com/featured/1920x1080/">
  

  


  

  

  <!-- for mathjax support -->
    
      <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
        TeX: { equationNumbers: { autoNumber: "AMS" } }
        });
      </script>
      <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    

</head>


<body>

  


  <nav class="navbar navbar-expand-xl navbar-light fixed-top navbar-custom top-nav-regular"><a class="navbar-brand" href="http://localhost:4000/">Abhay's Blog</a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  <div class="collapse navbar-collapse" id="main-navbar">
    <ul class="navbar-nav ml-auto">
          <li class="nav-item">
            <a class="nav-link" href="/">Home</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/aboutme">About Me</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/project">Projects</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/resource">Resources</a>
          </li></ul>
  </div>

  

  

</nav>


  <!-- TODO this file has become a mess, refactor it -->






  <div id="header-big-imgs" data-num-img=1
    
    
    
      
      data-img-src-1="https://source.unsplash.com/featured/1920x1080/"
    
    
    
  ></div>


<header class="header-section has-img">

<div class="big-img intro-header">
  <div class="container-md">
    <div class="row">
      <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
        <div class="post-heading">
          <h1>State Machine Compiler - A Small Language</h1>
          
            
              <h2 class="post-subheading">Generating Rust code from minimal specification</h2>
            
          

          
            <span class="post-meta">Posted on May 7, 2024</span>
            
            
              <!--- "ReadTime on GitHub Jekyll" (c) 2020 Ruby Griffith Ramirez, MIT License -->






  
  <span class="post-meta"><span class="d-none d-md-inline middot">&middot;</span> 38 minute read</span>


            
          
        </div>
      </div>
    </div>
  </div>
  <span class='img-desc'></span>
</div>

<div class="intro-header no-img">
  <div class="container-md">
    <div class="row">
      <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
        <div class="post-heading">
          <h1>State Machine Compiler - A Small Language</h1>
          
            
              <h2 class="post-subheading">Generating Rust code from minimal specification</h2>
            
          

          
            <span class="post-meta">Posted on May 7, 2024</span>
            
            
              <!--- "ReadTime on GitHub Jekyll" (c) 2020 Ruby Griffith Ramirez, MIT License -->






  
  <span class="post-meta"><span class="d-none d-md-inline middot">&middot;</span> 38 minute read</span>


            
          
        </div>
      </div>
    </div>
  </div>
</div>
</header>





<div class=" container-md ">
  <div class="row">
    <div class=" col-xl-8 offset-xl-2 col-lg-10 offset-lg-1 ">

      

      

      <article role="main" class="blog-post">
        <p>In the <a href="../2024-05-05-state-machine-compiler---rust-macros">previous post</a>, we decided to work 
with a much concise specification of the state machine.</p>

<p>Here is a specification for the state machine which 
will generate the sequence <code class="language-plaintext highlighter-rouge">001011011101111011111..</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>STATES: [b], o, q, p, f

SYMBOLS: 0, 1, e, x

TRANSITIONS:
b, *, P(e)-R-P(e)-R-P(0)-R-R-P(0)-L-L, o
o, 1, R-P(x)-L-L-L, o
o, 0, X, q
q, 0 | 1, R-R, q
q, X, P(1)-L, p
p, x, P(X)-R, q
p, e, R, f
p, X, L-L, p
f, *, R-R, f
f, X, P(0)-L-L, o
</code></pre></div></div>

<p>Since this particular state machine is a little
complex, we will be using a much simple state machine
example, one that generates the sequence <code class="language-plaintext highlighter-rouge">010101..</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>STATES: [a], b

SYMBOLS: 0, 1

TRANSITIONS:
a, a, P(0), b
b, 0, R, a
b, 1, R, a
</code></pre></div></div>

<p>So the expectation is that we will be able to generate
the rust code for the above state machine:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">fmt</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">io</span><span class="p">;</span>

<span class="c">// State declarations</span>
<span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq)]</span>
<span class="k">enum</span> <span class="n">TapeMachineState</span> <span class="p">{</span>
    <span class="n">a</span><span class="p">,</span>
    <span class="n">b</span><span class="p">,</span>
<span class="p">}</span>

<span class="c">// Symbol declarations, with `X` indicating a empty </span>
<span class="c">// tape block</span>
<span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq,</span> <span class="nd">Clone)]</span>
<span class="k">enum</span> <span class="n">TapeMachineSymbol</span> <span class="p">{</span>
    <span class="n">Symbol0</span><span class="p">,</span>
    <span class="n">Symbol1</span><span class="p">,</span>
    <span class="n">SymbolX</span><span class="p">,</span>
<span class="p">}</span>

<span class="c">// For printing the symbols</span>
<span class="k">impl</span> <span class="n">TapeMachineSymbol</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">as_str</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'static</span> <span class="nb">str</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
            <span class="nn">TapeMachineSymbol</span><span class="p">::</span><span class="n">Symbol0</span> <span class="k">=&gt;</span> <span class="s">"0"</span><span class="p">,</span>
            <span class="nn">TapeMachineSymbol</span><span class="p">::</span><span class="n">Symbol1</span> <span class="k">=&gt;</span> <span class="s">"1"</span><span class="p">,</span>
            <span class="nn">TapeMachineSymbol</span><span class="p">::</span><span class="n">SymbolX</span> <span class="k">=&gt;</span> <span class="s">"X"</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c">// Tape machine constituents</span>
<span class="k">struct</span> <span class="n">TapeMachine</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">state</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">TapeMachineState</span><span class="p">,</span>
    <span class="n">result</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">TapeMachineSymbol</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">index</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>


<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">TapeMachine</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">state</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">TapeMachineState</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">TapeMachineSymbol</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
        <span class="n">Self</span> <span class="p">{</span>
            <span class="n">state</span><span class="p">,</span>
            <span class="n">result</span><span class="p">,</span>
            <span class="n">index</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="c">// Print</span>
    <span class="k">fn</span> <span class="nf">p</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">symbol</span><span class="p">:</span> <span class="n">TapeMachineSymbol</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.result</span><span class="p">[</span><span class="k">self</span><span class="py">.index</span><span class="p">]</span> <span class="o">=</span> <span class="n">symbol</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c">// Move the head to the right</span>
    <span class="k">fn</span> <span class="nf">r</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.index</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c">// Move the head to the left</span>
    <span class="k">fn</span> <span class="nf">l</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.index</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="c">// Take the number of steps and the length of the </span>
    <span class="c">// tape as input</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Enter the number of steps:"</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">steps_input</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="nn">io</span><span class="p">::</span><span class="nf">stdin</span><span class="p">()</span><span class="nf">.read_line</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">steps_input</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">steps</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="n">steps_input</span><span class="nf">.trim</span><span class="p">()</span><span class="nf">.parse</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"Enter the total tape length:"</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">tape_length_input</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="nn">io</span><span class="p">::</span><span class="nf">stdin</span><span class="p">()</span><span class="nf">.read_line</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">tape_length_input</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">max_len</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="n">tape_length_input</span><span class="nf">.trim</span><span class="p">()</span><span class="nf">.parse</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
    

    <span class="c">// Initialize the tape machine</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">result</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="nn">TapeMachineSymbol</span><span class="p">::</span><span class="n">SymbolX</span><span class="p">;</span> <span class="n">max_len</span><span class="p">];</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">tape_machine</span> <span class="o">=</span> <span class="nn">TapeMachine</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="nn">TapeMachineState</span><span class="p">::</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">result</span><span class="p">);</span>

    <span class="c">// Run the simulation for the required number of </span>
    <span class="c">// steps</span>
    <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">steps</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span>
            <span class="s">"Step: {} State: {:?} Symbol: {:?}"</span><span class="p">,</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">tape_machine</span><span class="py">.state</span><span class="p">,</span> <span class="n">tape_machine</span><span class="py">.result</span><span class="p">[</span><span class="n">tape_machine</span><span class="py">.index</span><span class="p">]</span>
        <span class="p">);</span>

        <span class="c">// Actual simulation logic</span>
        <span class="k">match</span> <span class="p">(</span><span class="n">tape_machine</span><span class="py">.state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tape_machine</span><span class="py">.result</span><span class="p">[</span><span class="n">tape_machine</span><span class="py">.index</span><span class="p">])</span> <span class="p">{</span>
            <span class="p">(</span><span class="nn">TapeMachineState</span><span class="p">::</span><span class="n">b</span><span class="p">,</span> <span class="nn">TapeMachineSymbol</span><span class="p">::</span><span class="n">Symbol0</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">tape_machine</span><span class="nf">.r</span><span class="p">();</span>
                <span class="n">tape_machine</span><span class="nf">.p</span><span class="p">(</span><span class="nn">TapeMachineSymbol</span><span class="p">::</span><span class="n">Symbol1</span><span class="p">);</span>
                <span class="n">tape_machine</span><span class="py">.state</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nn">TapeMachineState</span><span class="p">::</span><span class="n">b</span><span class="p">;</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"Final State: {:?}"</span><span class="p">,</span> <span class="nn">TapeMachineState</span><span class="p">::</span><span class="n">b</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="p">(</span><span class="nn">TapeMachineState</span><span class="p">::</span><span class="n">b</span><span class="p">,</span> <span class="nn">TapeMachineSymbol</span><span class="p">::</span><span class="n">Symbol1</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">tape_machine</span><span class="nf">.r</span><span class="p">();</span>
                <span class="n">tape_machine</span><span class="nf">.p</span><span class="p">(</span><span class="nn">TapeMachineSymbol</span><span class="p">::</span><span class="n">Symbol0</span><span class="p">);</span>
                <span class="n">tape_machine</span><span class="py">.state</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nn">TapeMachineState</span><span class="p">::</span><span class="n">a</span><span class="p">;</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"Final State: {:?}"</span><span class="p">,</span> <span class="nn">TapeMachineState</span><span class="p">::</span><span class="n">a</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="p">(</span><span class="nn">TapeMachineState</span><span class="p">::</span><span class="n">a</span><span class="p">,</span> <span class="mi">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">tape_machine</span><span class="nf">.p</span><span class="p">(</span><span class="nn">TapeMachineSymbol</span><span class="p">::</span><span class="n">Symbol0</span><span class="p">);</span>
                <span class="n">tape_machine</span><span class="py">.state</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nn">TapeMachineState</span><span class="p">::</span><span class="n">b</span><span class="p">;</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"Final State: {:?}"</span><span class="p">,</span> <span class="nn">TapeMachineState</span><span class="p">::</span><span class="n">b</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="p">(</span><span class="mi">_</span><span class="p">,</span> <span class="mi">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span>
                    <span class="s">"State: {:?} Index: {:?} Symbol: {:?}"</span><span class="p">,</span>
                    <span class="n">tape_machine</span><span class="py">.state</span><span class="p">,</span> <span class="n">tape_machine</span><span class="py">.index</span><span class="p">,</span> <span class="n">tape_machine</span><span class="py">.result</span><span class="p">[</span><span class="n">tape_machine</span><span class="py">.index</span><span class="p">]</span>
                <span class="p">);</span>
                <span class="k">let</span> <span class="n">binary_result</span><span class="p">:</span> <span class="nb">String</span> <span class="o">=</span>
                    <span class="n">tape_machine</span><span class="py">.result</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="nf">.as_str</span><span class="p">())</span><span class="nf">.collect</span><span class="p">();</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">binary_result</span><span class="p">);</span>
                <span class="nd">panic!</span><span class="p">(</span><span class="s">"Invalid state reached"</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="c">// Print the tape content</span>
    <span class="k">let</span> <span class="n">binary_result</span><span class="p">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="n">tape_machine</span><span class="py">.result</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="nf">.as_str</span><span class="p">())</span><span class="nf">.collect</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">binary_result</span><span class="p">);</span>

    <span class="c">// Print without the empty tape blocks</span>
    <span class="k">let</span> <span class="n">clean_result</span><span class="p">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="n">tape_machine</span>
        <span class="py">.result</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.filter</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="nn">TapeMachineSymbol</span><span class="p">::</span><span class="n">SymbolX</span><span class="p">)</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="nf">.as_str</span><span class="p">())</span>
        <span class="nf">.collect</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"=========</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">clean_result</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>In order to generate this code directly from the
specification, we will need to parse the specification
into a data structure.</p>

<p>Here are few natural data structure to represent the
specification:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c">// A Trnasition condition can be either `*`</span>
<span class="c">// or `A | B | C | ...`</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">Condition</span> <span class="p">{</span>
    <span class="nf">OR</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">),</span>
    <span class="n">Star</span><span class="p">,</span>
<span class="p">}</span>

<span class="c">// A transition step can be either `R`, `L`, </span>
<span class="c">// `X`(erase the content) or `P(x)` ( print x to</span>
<span class="c">// the current head)</span>
<span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">TransitionStep</span> <span class="p">{</span>
    <span class="n">R</span><span class="p">,</span>
    <span class="n">L</span><span class="p">,</span>
    <span class="n">X</span><span class="p">,</span>
    <span class="nf">P</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span> <span class="c">// A function call</span>
<span class="p">}</span>


<span class="c">// A transition </span>
<span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Transition</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">initial_state</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">condition</span><span class="p">:</span> <span class="n">Condition</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">steps</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">TransitionStep</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">final_state</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
<span class="p">}</span>


<span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">ParseTree</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">states</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">initial_state</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">symbols</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">transitions</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Transition</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span></code></pre></figure>

<p>Once we have parsed the specification, generating
the rust code is just a matter of substituting the
right values in the template.</p>

<p>Parsing a text is typically broken into two steps:</p>

<ol>
  <li>Lexing: Breaking the text into tokens</li>
  <li>Parsing: Grouping tokens into recognizable 
structures</li>
</ol>

<p>We will be following [this tutorial][link_here] closely.</p>

<h2 id="lexing">Lexing</h2>

<p>A token is a value with a type. In our case,
we can expect the following types of tokens:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Clone,</span> <span class="nd">Copy)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">TokenType</span> <span class="p">{</span>
    <span class="c">// Special</span>
    <span class="n">EOF</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">NEWLINE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>

    <span class="c">// Keywords</span>
    <span class="n">STATES</span> <span class="o">=</span> <span class="mi">201</span><span class="p">,</span>
    <span class="n">SYMBOLS</span> <span class="o">=</span> <span class="mi">202</span><span class="p">,</span>
    <span class="n">TRANSITIONS</span> <span class="o">=</span> <span class="mi">203</span><span class="p">,</span>
    <span class="c">// Contextual Keywords</span>
    <span class="n">R</span> <span class="o">=</span> <span class="mi">104</span><span class="p">,</span>
    <span class="n">L</span> <span class="o">=</span> <span class="mi">105</span><span class="p">,</span>
    <span class="n">X</span> <span class="o">=</span> <span class="mi">106</span><span class="p">,</span>
    <span class="n">P</span> <span class="o">=</span> <span class="mi">107</span><span class="p">,</span>

    <span class="c">// Identifiers : Alphanumerics</span>
    <span class="n">IDENT</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>

    <span class="c">// Operators</span>
    <span class="n">OR</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
    <span class="n">LeftBracket</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
    <span class="n">RightBracket</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="n">COMMA</span> <span class="o">=</span> <span class="mi">11</span><span class="p">,</span>
    <span class="n">DASH</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
    <span class="n">LeftParen</span> <span class="o">=</span> <span class="mi">13</span><span class="p">,</span>
    <span class="n">RightParen</span> <span class="o">=</span> <span class="mi">14</span><span class="p">,</span>
    <span class="n">STAR</span> <span class="o">=</span> <span class="mi">15</span><span class="p">,</span>
    <span class="n">COLON</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
<span class="p">}</span></code></pre></figure>

<p>Lexer will simply go over the text separated by
whitespaces and return a token or thrown an error
in case of an invalid value.</p>

<p>As the [tutorial][link_here] suggests, let’s first
outline the interfaces of the lexer:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Token</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">text</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">kind</span><span class="p">:</span> <span class="n">TokenType</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Lexer</span> <span class="p">{</span>
    <span class="n">source</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">char</span><span class="o">&gt;</span><span class="p">,</span> <span class="c">// The full source code</span>
    <span class="k">pub</span> <span class="n">cur_char</span><span class="p">:</span> <span class="nb">char</span><span class="p">,</span> <span class="c">// The current character</span>
    <span class="n">cur_pos</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="c">// The current position in </span>
                    <span class="c">// the source </span>
    <span class="p">}</span>

<span class="k">impl</span> <span class="n">Lexer</span> <span class="p">{</span>

    <span class="c">// Initialize the lexer</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">source</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{}</span>

    <span class="c">// Get the current character</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">cur_char</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">char</span> <span class="p">{}</span>

    <span class="c">// Move to the next character</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">next_char</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{}</span>

    <span class="c">// Peek at the next character, does not move</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">peek</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">char</span> <span class="p">{}</span>

    <span class="c">// Abort the lexer with an error message</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">abort</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="p">{}</span>

    <span class="c">// Skip whitespaces</span>
    <span class="k">fn</span> <span class="nf">skip_whitespace</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{}</span>

    <span class="c">// Skip comments</span>
    <span class="k">fn</span> <span class="nf">skip_comment</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{}</span>

    <span class="c">// Get the next token</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_token</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Token</span><span class="o">&gt;</span> <span class="p">{</span>

        <span class="c">// Skip whitespaces</span>
        <span class="c">// Skip comments</span>

        <span class="c">// Match the operators first</span>

        <span class="c">// If the current character is alphanumeric</span>
        <span class="c">// then the following word can be an identifier</span>
        <span class="c">// or a keyword</span>

        <span class="c">// construct the whole word and check if it is </span>
        <span class="c">// a keyword or an identifier</span>


        <span class="c">// Throw an error if the current character if</span>
        <span class="c">// not a valid token</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>I’ve outlined the interfaces, since the implementation
is straightforward, we will not be going through it,
line by line.</p>

<details>
<summary>Full Lexer Code</summary>


<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">use</span> <span class="k">log</span><span class="p">::{</span><span class="n">error</span><span class="p">,</span> <span class="n">info</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">str</span><span class="p">::</span><span class="n">FromStr</span><span class="p">;</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Clone,</span> <span class="nd">Copy)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">TokenType</span> <span class="p">{</span>
    <span class="c">// Special</span>
    <span class="n">EOF</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">NEWLINE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>

    <span class="c">// Keywords</span>
    <span class="n">STATES</span> <span class="o">=</span> <span class="mi">201</span><span class="p">,</span>
    <span class="n">SYMBOLS</span> <span class="o">=</span> <span class="mi">202</span><span class="p">,</span>
    <span class="n">TRANSITIONS</span> <span class="o">=</span> <span class="mi">203</span><span class="p">,</span>
    <span class="c">// Contextual Keywords</span>
    <span class="n">R</span> <span class="o">=</span> <span class="mi">104</span><span class="p">,</span>
    <span class="n">L</span> <span class="o">=</span> <span class="mi">105</span><span class="p">,</span>
    <span class="n">X</span> <span class="o">=</span> <span class="mi">106</span><span class="p">,</span>
    <span class="n">P</span> <span class="o">=</span> <span class="mi">107</span><span class="p">,</span>

    <span class="c">// Identifiers : Alphanumerics</span>
    <span class="n">IDENT</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>

    <span class="c">// Operators</span>
    <span class="n">OR</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
    <span class="n">LeftBracket</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
    <span class="n">RightBracket</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="n">COMMA</span> <span class="o">=</span> <span class="mi">11</span><span class="p">,</span>
    <span class="n">DASH</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
    <span class="n">LeftParen</span> <span class="o">=</span> <span class="mi">13</span><span class="p">,</span>
    <span class="n">RightParen</span> <span class="o">=</span> <span class="mi">14</span><span class="p">,</span>
    <span class="n">STAR</span> <span class="o">=</span> <span class="mi">15</span><span class="p">,</span>
    <span class="n">COLON</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">FromStr</span> <span class="k">for</span> <span class="n">TokenType</span> <span class="p">{</span>
    <span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span> <span class="nb">String</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span> <span class="nn">Self</span><span class="p">::</span><span class="nb">Err</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">s</span> <span class="p">{</span>
            <span class="s">"EOF"</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">EOF</span><span class="p">),</span>
            <span class="s">"NEWLINE"</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">NEWLINE</span><span class="p">),</span>
            <span class="s">"STATES"</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">STATES</span><span class="p">),</span>
            <span class="s">"SYMBOLS"</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">SYMBOLS</span><span class="p">),</span>
            <span class="s">"TRANSITIONS"</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">TRANSITIONS</span><span class="p">),</span>
            <span class="s">"R"</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">R</span><span class="p">),</span>
            <span class="s">"L"</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">L</span><span class="p">),</span>
            <span class="s">"P"</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">P</span><span class="p">),</span>
            <span class="s">"X"</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">X</span><span class="p">),</span>
            <span class="s">"IDENT"</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">IDENT</span><span class="p">),</span>
            <span class="s">"OR"</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">OR</span><span class="p">),</span>
            <span class="s">"LEFT_BRACKET"</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">LeftBracket</span><span class="p">),</span>
            <span class="s">"RIGHT_BRACKET"</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">RightBracket</span><span class="p">),</span>
            <span class="s">"COMMA"</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">COMMA</span><span class="p">),</span>
            <span class="s">"DASH"</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">DASH</span><span class="p">),</span>
            <span class="s">"LEFT_PAREN"</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">LeftParen</span><span class="p">),</span>
            <span class="s">"RIGHT_PAREN"</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">RightParen</span><span class="p">),</span>
            <span class="s">"STAR"</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">STAR</span><span class="p">),</span>
            <span class="s">"COLON"</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">COLON</span><span class="p">),</span>
            <span class="mi">_</span> <span class="k">=&gt;</span> <span class="nf">Err</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"Unknown token type: {}"</span><span class="p">,</span> <span class="n">s</span><span class="p">)),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Token</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">text</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">kind</span><span class="p">:</span> <span class="n">TokenType</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Token</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">check_if_keyword</span><span class="p">(</span><span class="n">token_text</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">TokenType</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">token_type</span> <span class="o">=</span> <span class="nn">TokenType</span><span class="p">::</span><span class="nf">from_str</span><span class="p">(</span><span class="n">token_text</span><span class="p">);</span>
        <span class="k">match</span> <span class="n">token_type</span> <span class="p">{</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">t</span> <span class="k">as</span> <span class="nb">i32</span> <span class="o">&gt;</span> <span class="mi">100</span> <span class="p">{</span>
                    <span class="nf">Some</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="nb">None</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="nf">Err</span><span class="p">(</span><span class="mi">_</span><span class="n">s</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nb">None</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Lexer</span> <span class="p">{</span>
    <span class="n">source</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">char</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">cur_char</span><span class="p">:</span> <span class="nb">char</span><span class="p">,</span>
    <span class="n">cur_pos</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Lexer</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">source</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
        <span class="nd">info!</span><span class="p">(</span><span class="s">"Initializing Lexer"</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">source_chars</span> <span class="o">=</span> <span class="n">source</span><span class="nf">.chars</span><span class="p">()</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="mi">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>
        <span class="n">source_chars</span><span class="nf">.push</span><span class="p">(</span><span class="sc">'\n'</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">cur_char</span> <span class="o">=</span> <span class="k">if</span> <span class="n">source_chars</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="n">source_chars</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="sc">'\n'</span>
        <span class="p">};</span>

        <span class="n">Lexer</span> <span class="p">{</span>
            <span class="n">source</span><span class="p">:</span> <span class="n">source_chars</span><span class="p">,</span>
            <span class="n">cur_char</span><span class="p">,</span>
            <span class="n">cur_pos</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">cur_char</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">char</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.source</span><span class="p">[</span><span class="k">self</span><span class="py">.cur_pos</span><span class="p">]</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">next_char</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.cur_pos</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.cur_pos</span> <span class="o">&gt;=</span> <span class="k">self</span><span class="py">.source</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.cur_char</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span> <span class="c">// EOF</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.cur_char</span> <span class="o">=</span> <span class="k">self</span><span class="py">.source</span><span class="p">[</span><span class="k">self</span><span class="py">.cur_pos</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">peek</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">char</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.cur_pos</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="k">self</span><span class="py">.source</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
            <span class="sc">'\0'</span> <span class="c">// EOF</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.source</span><span class="p">[</span><span class="k">self</span><span class="py">.cur_pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">abort</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">error!</span><span class="p">(</span><span class="s">"Lexical Error: {}"</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>
        <span class="nd">panic!</span><span class="p">(</span><span class="s">"Lexical Error: {}"</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">skip_whitespace</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span> <span class="k">self</span><span class="py">.cur_char</span> <span class="o">==</span> <span class="sc">' '</span> <span class="p">||</span> <span class="k">self</span><span class="py">.cur_char</span> <span class="o">==</span> <span class="sc">'\t'</span> <span class="p">||</span> <span class="k">self</span><span class="py">.cur_char</span> <span class="o">==</span> <span class="sc">'\r'</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.next_char</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">skip_comment</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.cur_char</span> <span class="o">==</span> <span class="sc">'#'</span> <span class="p">{</span>
            <span class="k">while</span> <span class="k">self</span><span class="py">.cur_char</span> <span class="o">!=</span> <span class="sc">'\n'</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.next_char</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_token</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Token</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.skip_whitespace</span><span class="p">();</span>
        <span class="k">self</span><span class="nf">.skip_comment</span><span class="p">();</span>

        <span class="k">let</span> <span class="n">token</span> <span class="o">=</span> <span class="k">match</span> <span class="k">self</span><span class="py">.cur_char</span> <span class="p">{</span>
            <span class="sc">'\n'</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="n">Token</span> <span class="p">{</span>
                <span class="n">text</span><span class="p">:</span> <span class="k">self</span><span class="py">.cur_char</span><span class="nf">.to_string</span><span class="p">(),</span>
                <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">NEWLINE</span><span class="p">,</span>
            <span class="p">}),</span>
            <span class="sc">'|'</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="n">Token</span> <span class="p">{</span>
                <span class="n">text</span><span class="p">:</span> <span class="k">self</span><span class="py">.cur_char</span><span class="nf">.to_string</span><span class="p">(),</span>
                <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">OR</span><span class="p">,</span>
            <span class="p">}),</span>
            <span class="sc">'['</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="n">Token</span> <span class="p">{</span>
                <span class="n">text</span><span class="p">:</span> <span class="k">self</span><span class="py">.cur_char</span><span class="nf">.to_string</span><span class="p">(),</span>
                <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">LeftBracket</span><span class="p">,</span>
            <span class="p">}),</span>
            <span class="sc">']'</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="n">Token</span> <span class="p">{</span>
                <span class="n">text</span><span class="p">:</span> <span class="k">self</span><span class="py">.cur_char</span><span class="nf">.to_string</span><span class="p">(),</span>
                <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">RightBracket</span><span class="p">,</span>
            <span class="p">}),</span>
            <span class="sc">','</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="n">Token</span> <span class="p">{</span>
                <span class="n">text</span><span class="p">:</span> <span class="k">self</span><span class="py">.cur_char</span><span class="nf">.to_string</span><span class="p">(),</span>
                <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">COMMA</span><span class="p">,</span>
            <span class="p">}),</span>
            <span class="sc">'-'</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="n">Token</span> <span class="p">{</span>
                <span class="n">text</span><span class="p">:</span> <span class="k">self</span><span class="py">.cur_char</span><span class="nf">.to_string</span><span class="p">(),</span>
                <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">DASH</span><span class="p">,</span>
            <span class="p">}),</span>
            <span class="sc">'('</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="n">Token</span> <span class="p">{</span>
                <span class="n">text</span><span class="p">:</span> <span class="k">self</span><span class="py">.cur_char</span><span class="nf">.to_string</span><span class="p">(),</span>
                <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">LeftParen</span><span class="p">,</span>
            <span class="p">}),</span>
            <span class="sc">')'</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="n">Token</span> <span class="p">{</span>
                <span class="n">text</span><span class="p">:</span> <span class="k">self</span><span class="py">.cur_char</span><span class="nf">.to_string</span><span class="p">(),</span>
                <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">RightParen</span><span class="p">,</span>
            <span class="p">}),</span>
            <span class="sc">'*'</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="n">Token</span> <span class="p">{</span>
                <span class="n">text</span><span class="p">:</span> <span class="k">self</span><span class="py">.cur_char</span><span class="nf">.to_string</span><span class="p">(),</span>
                <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">STAR</span><span class="p">,</span>
            <span class="p">}),</span>
            <span class="sc">':'</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="n">Token</span> <span class="p">{</span>
                <span class="n">text</span><span class="p">:</span> <span class="k">self</span><span class="py">.cur_char</span><span class="nf">.to_string</span><span class="p">(),</span>
                <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">COLON</span><span class="p">,</span>
            <span class="p">}),</span>
            <span class="sc">'\0'</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="n">Token</span> <span class="p">{</span>
                <span class="n">text</span><span class="p">:</span> <span class="k">self</span><span class="py">.cur_char</span><span class="nf">.to_string</span><span class="p">(),</span>
                <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">EOF</span><span class="p">,</span>
            <span class="p">}),</span>
            <span class="mi">_</span> <span class="k">if</span> <span class="k">self</span><span class="py">.cur_char</span><span class="nf">.is_alphanumeric</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">start_pos</span> <span class="o">=</span> <span class="k">self</span><span class="py">.cur_pos</span><span class="p">;</span>
                <span class="k">while</span> <span class="k">self</span><span class="nf">.peek</span><span class="p">()</span><span class="nf">.is_alphanumeric</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">self</span><span class="nf">.next_char</span><span class="p">();</span>
                <span class="p">}</span>
                <span class="k">let</span> <span class="n">tok_text</span><span class="p">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="k">self</span><span class="py">.source</span><span class="p">[</span><span class="n">start_pos</span><span class="o">..=</span><span class="k">self</span><span class="py">.cur_pos</span><span class="p">]</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.collect</span><span class="p">();</span>
                <span class="k">match</span> <span class="nn">Token</span><span class="p">::</span><span class="nf">check_if_keyword</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok_text</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nf">Some</span><span class="p">(</span><span class="n">keyword</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="n">Token</span> <span class="p">{</span>
                        <span class="n">text</span><span class="p">:</span> <span class="n">tok_text</span><span class="p">,</span>
                        <span class="n">kind</span><span class="p">:</span> <span class="n">keyword</span><span class="p">,</span>
                    <span class="p">}),</span>
                    <span class="nb">None</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="n">Token</span> <span class="p">{</span>
                        <span class="n">text</span><span class="p">:</span> <span class="n">tok_text</span><span class="p">,</span>
                        <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">IDENT</span><span class="p">,</span>
                    <span class="p">}),</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="mi">_</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.abort</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">format!</span><span class="p">(</span><span class="s">"Unknown token: {}"</span><span class="p">,</span> <span class="k">self</span><span class="py">.cur_char</span><span class="p">));</span>
                <span class="nb">None</span>
            <span class="p">}</span>
        <span class="p">};</span>

        <span class="k">self</span><span class="nf">.next_char</span><span class="p">();</span>
        <span class="n">token</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>


</details>

<p>To test the lexer, take a look at the following code:</p>

<details>
<summary>A Sample Lexer Test Code</summary>


<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">test_keywords_and_identifiers</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">code</span> <span class="o">=</span> <span class="s">"
        STATES: [A], B, C1
        SYMBOLS: [0 , 1, X, R]
        TRANSITIONS: [A, 0 | 1, L-R-P(X), B], [B, * , L , C1]
    "</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">expected</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">NEWLINE</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">"STATES"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">STATES</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">":"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">COLON</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">"["</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">LeftBracket</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">"A"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">IDENT</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">"]"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">RightBracket</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">","</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">COMMA</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">"B"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">IDENT</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">","</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">COMMA</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">"C1"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">IDENT</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">NEWLINE</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">"SYMBOLS"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">SYMBOLS</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">":"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">COLON</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">"["</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">LeftBracket</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">"0"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">IDENT</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">","</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">COMMA</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">"1"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">IDENT</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">","</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">COMMA</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">"X"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">X</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">","</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">COMMA</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">"R"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">R</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">"]"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">RightBracket</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">NEWLINE</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">"TRANSITIONS"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">TRANSITIONS</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">":"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">COLON</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">"["</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">LeftBracket</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">"A"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">IDENT</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">","</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">COMMA</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">"0"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">IDENT</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">"|"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">OR</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">"1"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">IDENT</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">","</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">COMMA</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">"L"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">L</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">"-"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">DASH</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">"R"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">R</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">"-"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">DASH</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">"P"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">P</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">"("</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">LeftParen</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">"X"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">X</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">")"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">RightParen</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">","</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">COMMA</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">"B"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">IDENT</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">"]"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">RightBracket</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">","</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">COMMA</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">"["</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">LeftBracket</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">"B"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">IDENT</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">","</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">COMMA</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">"*"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">STAR</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">","</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">COMMA</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">"L"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">L</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">","</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">COMMA</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">"C1"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">IDENT</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">"]"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">RightBracket</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">NEWLINE</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">NEWLINE</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">];</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">lexer</span> <span class="o">=</span> <span class="nn">Lexer</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">code</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">=</span> <span class="n">lexer</span><span class="nf">.get_token</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">token</span><span class="py">.kind</span> <span class="o">==</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">EOF</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">result</span><span class="nf">.push</span><span class="p">(</span><span class="n">token</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">expected</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>


</details>

<p>To move on to the next step, we will need to
make sense of these series of tokens.</p>

<h2 id="parsing">Parsing</h2>

<p>In order to parse we will follow this general approach:</p>

<ol>
  <li>Take a look at the current token</li>
  <li>Based on the context, decide whether we expect
it to be a certain type of token:
 a. The token type is required:
     i. Is this token present? Consume it and 
     update the parse tree. 
     ii. Otherwise, throw an error.
 b. Is this token type optional? 
    i. Try to consume it.
    ii. If its not present, then move on.</li>
</ol>

<p>How do we know which tokens type we expect at any 
place?
A Grammer of our language will
help:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c">// A program is a series of declarations</span>
<span class="n">PROGRAM</span><span class="o">=</span> <span class="n">STATES_DECLARATION</span> <span class="n">SYMBOLS_DECLARATION</span> <span class="n">TRANSITIONS_DECLARATION</span>

<span class="c">// A declaration of states is comma separated list of </span>
<span class="c">// identifiers</span>
<span class="n">STATES_DECLARATION</span><span class="p">:</span> <span class="n">STATES</span> <span class="sc">':'</span> <span class="p">[</span><span class="n">STATES_IDENTIFIERS</span> <span class="sc">','</span><span class="p">]</span> <span class="sc">'['</span> <span class="n">STATE_IDENTIFIERS</span> <span class="sc">']'</span>   <span class="p">[</span><span class="n">STATES_IDENTIFIERS</span><span class="p">]</span> <span class="n">NEWLINE</span>
<span class="n">STATE_IDENTIFIERS</span><span class="p">:</span> <span class="nf">STATE_IDENTIFIER</span> <span class="p">(</span><span class="sc">','</span> <span class="n">STATE_IDENTIFIER</span><span class="p">)</span><span class="o">*</span>

<span class="c">// A declaration of symbols is comma separated list of</span>
<span class="c">// identifiers</span>
<span class="n">SYMBOLS_DECLARATION</span><span class="p">:</span> <span class="n">SYMBOLS</span> <span class="sc">':'</span> <span class="sc">'['</span> <span class="n">SYMBOL_IDENTIFIERS</span> <span class="sc">']'</span> <span class="n">NEWLINE</span>
<span class="n">SYMBOL_IDENTIFIERS</span><span class="p">:</span> <span class="nf">SYMBOL_IDENTIFIER</span> <span class="p">(</span><span class="sc">','</span> <span class="n">SYMBOL_IDENTIFIER</span><span class="p">)</span><span class="o">*</span>

<span class="c">// A declaration of transitions is comma separated </span>
<span class="c">// list of transition declarations</span>
<span class="n">TRANSITIONS_DECLARATION</span><span class="p">:</span> <span class="n">TRANSITIONS</span> <span class="sc">':'</span> <span class="p">(</span><span class="n">NEWLINE</span> <span class="n">TRANSITION_DECLARATION</span><span class="p">)</span><span class="o">*</span> 


<span class="c">// A transition declaration </span>
<span class="n">TRANSITION_DECLARATION</span><span class="p">:</span> <span class="n">INITIAL_STATE_IDENTIFIER</span> <span class="sc">','</span> <span class="n">TRANSITION_CONDITIONS</span> <span class="sc">','</span> <span class="n">TRANSITION_STEPS</span><span class="p">,</span> <span class="n">FINAL_STATE_IDENTIFIER</span>
<span class="n">TRANSITION_CONDITIONS</span><span class="p">:</span> <span class="n">STAR</span> <span class="p">|</span> <span class="nf">SYMBOL_IDENTIFIER</span> <span class="p">(</span> <span class="sc">'|'</span> <span class="n">SYMBOL_IDENTIFIER</span> <span class="p">)</span><span class="o">*</span>
<span class="n">TRANSITION_STEPS</span><span class="p">:</span> <span class="nb">None</span> <span class="p">|</span> <span class="nf">TRANSITION_STEP</span> <span class="p">(</span><span class="sc">'-'</span> <span class="n">TRANSITION_STEP</span><span class="p">)</span><span class="o">*</span>
<span class="n">TRANSITION_STEP</span><span class="p">:</span> <span class="n">R</span> <span class="p">|</span> <span class="n">L</span> <span class="p">|</span> <span class="n">P</span> <span class="sc">'('</span> <span class="n">SYMBOL_IDENTIFIER</span> <span class="sc">')'</span>

<span class="n">STATE_IDENTIFIER</span><span class="p">:</span> <span class="n">IDENTIFIER</span>
<span class="n">SYMBOL_IDENTIFIER</span><span class="p">:</span> <span class="n">IDENTIFIER</span></code></pre></figure>

<p>The above grammer, recursively defines what a valid
program is. It starts with a <code class="language-plaintext highlighter-rouge">PROGRAM</code> which is a
series of declarations and then goes on to define
what different declarations are.</p>

<p>This grammer says that we expect <code class="language-plaintext highlighter-rouge">SYMBOLS_DECLARATION</code> to come after <code class="language-plaintext highlighter-rouge">STATES_DECLARATION</code>.</p>

<p>In our parsing logic, at any stage, we will be 
expecting a series of tokens as specified by the
grammer.
For example the top level logic will be following:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust">    <span class="c">// Parse the entire program:</span>
    <span class="c">// NEWLINE? states_declaration symbols_declaration transitions_declaration NEWLINE? EOF</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">program</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="c">// Consume newlines</span>
        <span class="k">while</span> <span class="k">self</span><span class="nf">.try_consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">NEWLINE</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{}</span>
        <span class="c">// Parse the states declaration</span>
        <span class="k">self</span><span class="nf">.states_declaration</span><span class="p">();</span>

        <span class="c">// Parse the symbols declaration</span>
        <span class="k">self</span><span class="nf">.symbols_declaration</span><span class="p">();</span>

        <span class="c">// Parse the transitions declaration</span>
        <span class="k">self</span><span class="nf">.transitions_declaration</span><span class="p">();</span>

        <span class="c">// Consume newlines</span>
        <span class="k">while</span> <span class="k">self</span><span class="nf">.try_consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">NEWLINE</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{}</span>

        <span class="c">// Expect the end of the file</span>
        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">EOF</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>
        <span class="nd">debug!</span><span class="p">(</span><span class="s">"PROGRAM"</span><span class="p">);</span>
    <span class="p">}</span></code></pre></figure>

<p>The <code class="language-plaintext highlighter-rouge">states_declaration</code> will be defined as follows:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust">    <span class="c">// Parse a states declaration: STATES ':' state_identifier_list NEWLINE</span>
    <span class="k">fn</span> <span class="nf">states_declaration</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">STATES</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>
        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">COLON</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>
        <span class="k">self</span><span class="nf">.state_identifier_list</span><span class="p">();</span>
        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">NEWLINE</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>
        <span class="nd">debug!</span><span class="p">(</span><span class="s">"STATES_DECLARATION"</span><span class="p">);</span>
    <span class="p">}</span></code></pre></figure>

<p>Let’s focus on the <code class="language-plaintext highlighter-rouge">consume</code> function:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust">    <span class="c">// Consume the current token if it matches the expected token type</span>
    <span class="c">// If not, abort with an error message</span>
    <span class="c">// Execute the optional action if provided</span>
    <span class="k">fn</span> <span class="n">consume</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">expected</span><span class="p">:</span> <span class="n">TokenType</span><span class="p">,</span> <span class="n">action</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">)</span></code></pre></figure>

<p>There is another variant of <code class="language-plaintext highlighter-rouge">consume</code> which is <code class="language-plaintext highlighter-rouge">try_consume</code>:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust">    <span class="c">// Try to consume the current token if it matches the expected token type</span>
    <span class="c">// If successful, print the token type and text (if available) and execute the optional action</span>
    <span class="c">// Return true if the token was consumed, false otherwise</span>
    <span class="k">fn</span> <span class="n">try_consume</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">kind</span><span class="p">:</span> <span class="n">TokenType</span><span class="p">,</span> <span class="n">action</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span></code></pre></figure>

<p>Let’s look at what an <code class="language-plaintext highlighter-rouge">action</code> might look like, in case we happen to be
matching a initial state identifier:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust">    <span class="c">// Parse an initial state identifier: [IDENT]</span>
    <span class="k">fn</span> <span class="nf">initial_state_identifier</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">LeftBracket</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">initial_state</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span>
            <span class="nn">TokenType</span><span class="p">::</span><span class="n">IDENT</span><span class="p">,</span>

            <span class="c">// action: Push the text of the token to the initial state</span>
            <span class="nf">Some</span><span class="p">(|</span><span class="n">token</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Token</span><span class="p">|</span> <span class="p">{</span>
                <span class="n">initial_state</span><span class="nf">.push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="n">token</span><span class="py">.text</span><span class="p">);</span>
            <span class="p">}),</span>
        <span class="p">);</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.tree.initial_state</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>

            <span class="c">// Action result: Set the initial state and</span>
            <span class="c">// push the state to the states list</span>
            <span class="k">self</span><span class="py">.tree.initial_state</span> <span class="o">=</span> <span class="n">initial_state</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="k">self</span><span class="py">.tree.states</span><span class="nf">.push</span><span class="p">(</span><span class="n">initial_state</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.abort</span><span class="p">(</span><span class="s">"Initial state already defined."</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">RightBracket</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>
        <span class="nd">debug!</span><span class="p">(</span><span class="s">"INITIAL_STATE_IDENTIFIER"</span><span class="p">);</span>
    <span class="p">}</span></code></pre></figure>

<p>An example where we are using <code class="language-plaintext highlighter-rouge">try_consume</code>:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust">    <span class="k">fn</span> <span class="nf">transition_steps</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.transition_step</span><span class="p">();</span>
        <span class="c">// There might or might not be a dash, if there is a dash</span>
        <span class="c">// then we expect another transition step</span>
        <span class="k">while</span> <span class="k">self</span><span class="nf">.try_consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">DASH</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.transition_step</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="nd">debug!</span><span class="p">(</span><span class="s">"TRANSITION_STEPS"</span><span class="p">);</span>
    <span class="p">}</span></code></pre></figure>

<p>To summarise, let’s right down the interfaces of parser:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span> <span class="n">Parser</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">lexer</span><span class="p">:</span> <span class="n">Lexer</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
        <span class="c">// Initialize the Parser</span>
    <span class="p">}</span>

    <span class="c">// Check if the current token matches the expected token type</span>
    <span class="k">fn</span> <span class="nf">check_token</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">kind</span><span class="p">:</span> <span class="n">TokenType</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span><span class="p">;</span>

    <span class="c">// Check if the next token has the expected token type</span>
    <span class="k">fn</span> <span class="nf">check_peek</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">kind</span><span class="p">:</span> <span class="n">TokenType</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span><span class="p">;</span>

    <span class="c">// Advance to the next token</span>
    <span class="k">fn</span> <span class="nf">next_token</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">);</span>

    <span class="c">// Abort the parsing process with an error message</span>
    <span class="k">fn</span> <span class="nf">abort</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">);</span>

    <span class="c">// Try to consume the current token if it matches the expected token type</span>
    <span class="c">// If successful, print the token type and text (if available) and execute the optional action</span>
    <span class="c">// Return true if the token was consumed, false otherwise</span>
    <span class="k">fn</span> <span class="n">try_consume</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">kind</span><span class="p">:</span> <span class="n">TokenType</span><span class="p">,</span> <span class="n">action</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span>
    <span class="k">where</span>
        <span class="n">F</span><span class="p">:</span> <span class="nf">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">);</span>

    <span class="c">// Consume the current token if it matches the expected token type</span>
    <span class="c">// If not, abort with an error message</span>
    <span class="c">// Execute the optional action if provided</span>
    <span class="k">fn</span> <span class="n">consume</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">expected</span><span class="p">:</span> <span class="n">TokenType</span><span class="p">,</span> <span class="n">action</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">F</span><span class="p">:</span> <span class="nf">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">);</span>

    <span class="c">// Parse an initial state identifier: [IDENT]</span>
    <span class="k">fn</span> <span class="nf">initial_state_identifier</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">);</span>

    <span class="c">// Parse a list of state identifiers: IDENT (',' IDENT)*</span>
    <span class="k">fn</span> <span class="nf">state_identifier_list</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">);</span>

    <span class="c">// Parse a states declaration: STATES ':' state_identifier_list NEWLINE</span>
    <span class="k">fn</span> <span class="nf">states_declaration</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">);</span>

    <span class="c">// Parse a list of symbol identifiers: IDENT (',' IDENT)*</span>
    <span class="k">fn</span> <span class="nf">symbol_identifiers</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">);</span>

    <span class="c">// Parse a symbols declaration: SYMBOLS ':' symbol_identifiers NEWLINE</span>
    <span class="k">fn</span> <span class="nf">symbols_declaration</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">);</span>

    <span class="c">// Parse a transition step: R | L | P '(' IDENT ')' | X</span>
    <span class="k">fn</span> <span class="nf">transition_step</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">);</span>

    <span class="k">fn</span> <span class="nf">transition_steps</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">);</span>

    <span class="c">// Parse a list of transition conditions: IDENT ('|' IDENT)*</span>
    <span class="k">fn</span> <span class="nf">transition_condition_list</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">);</span>

    <span class="c">// Parse transition conditions: '*' | transition_condition_list</span>
    <span class="k">fn</span> <span class="nf">transition_conditions</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">);</span>

    <span class="c">// Parse a transition declaration:</span>
    <span class="c">// IDENT ',' transition_conditions ',' transition_steps ',' IDENT</span>
    <span class="k">fn</span> <span class="nf">transition_declaration</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">);</span>

    <span class="c">// Parse transitions declarations:</span>
    <span class="c">// TRANSITIONS ':' (NEWLINE transition_declaration)*</span>
    <span class="k">fn</span> <span class="nf">transitions_declaration</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">);</span>

    <span class="c">// Parse the entire program:</span>
    <span class="c">// NEWLINE? states_declaration symbols_declaration transitions_declaration NEWLINE? EOF</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">program</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Each of the functions, trying to parse a certain rule, when successful, will
update the <code class="language-plaintext highlighter-rouge">ParseTree</code> with the parsed data, otherwise throw an error.</p>

<details>
<summary>Full Parser Code</summary>


<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">use</span> <span class="nn">crate</span><span class="p">::</span><span class="nn">lexer</span><span class="p">::{</span><span class="n">Lexer</span><span class="p">,</span> <span class="n">Token</span><span class="p">,</span> <span class="n">TokenType</span><span class="p">};</span>
<span class="k">use</span> <span class="k">log</span><span class="p">::{</span><span class="n">debug</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">info</span><span class="p">};</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">Condition</span> <span class="p">{</span>
    <span class="nf">OR</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">),</span>
    <span class="n">Star</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">TransitionStep</span> <span class="p">{</span>
    <span class="n">R</span><span class="p">,</span>
    <span class="n">L</span><span class="p">,</span>
    <span class="n">X</span><span class="p">,</span>
    <span class="nf">P</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span> <span class="c">// A function call</span>
<span class="p">}</span>

<span class="k">trait</span> <span class="n">FromTokenAndValue</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">from_token_and_value</span><span class="p">(</span><span class="n">token</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Token</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Self</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">FromTokenAndValue</span> <span class="k">for</span> <span class="n">TransitionStep</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">from_token_and_value</span><span class="p">(</span><span class="n">token</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Token</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">token</span><span class="py">.kind</span> <span class="p">{</span>
            <span class="nn">TokenType</span><span class="p">::</span><span class="n">R</span> <span class="k">=&gt;</span> <span class="nn">TransitionStep</span><span class="p">::</span><span class="n">R</span><span class="p">,</span>
            <span class="nn">TokenType</span><span class="p">::</span><span class="n">L</span> <span class="k">=&gt;</span> <span class="nn">TransitionStep</span><span class="p">::</span><span class="n">L</span><span class="p">,</span>
            <span class="nn">TokenType</span><span class="p">::</span><span class="n">X</span> <span class="k">=&gt;</span> <span class="nn">TransitionStep</span><span class="p">::</span><span class="n">X</span><span class="p">,</span>
            <span class="nn">TokenType</span><span class="p">::</span><span class="n">P</span> <span class="k">=&gt;</span> <span class="nn">TransitionStep</span><span class="p">::</span><span class="nf">P</span><span class="p">(</span><span class="n">value</span><span class="nf">.unwrap</span><span class="p">()),</span>
            <span class="mi">_</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"Invalid token type for TransitionStep"</span><span class="p">),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Transition</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">initial_state</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">condition</span><span class="p">:</span> <span class="n">Condition</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">steps</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">TransitionStep</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">final_state</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Transition</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
        <span class="n">Transition</span> <span class="p">{</span>
            <span class="n">initial_state</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
            <span class="n">condition</span><span class="p">:</span> <span class="nn">Condition</span><span class="p">::</span><span class="nf">OR</span><span class="p">(</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">()),</span>
            <span class="n">steps</span><span class="p">:</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
            <span class="n">final_state</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">ParseTree</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">states</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">initial_state</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">symbols</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">transitions</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Transition</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>


<span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Parser</span> <span class="p">{</span>
    <span class="n">lexer</span><span class="p">:</span> <span class="n">Lexer</span><span class="p">,</span>
    <span class="n">cur_token</span><span class="p">:</span> <span class="n">Token</span><span class="p">,</span>
    <span class="n">peek_token</span><span class="p">:</span> <span class="n">Token</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">tree</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Parser</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">lexer</span><span class="p">:</span> <span class="n">Lexer</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
        <span class="nd">info!</span><span class="p">(</span><span class="s">"Initializing Parser"</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">parser</span> <span class="o">=</span> <span class="n">Parser</span> <span class="p">{</span>
            <span class="n">lexer</span><span class="p">,</span>
            <span class="n">cur_token</span><span class="p">:</span> <span class="n">Token</span> <span class="p">{</span>
                <span class="n">text</span><span class="p">:</span> <span class="s">"</span><span class="se">\0</span><span class="s">"</span><span class="nf">.to_string</span><span class="p">(),</span>
                <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">EOF</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="n">peek_token</span><span class="p">:</span> <span class="n">Token</span> <span class="p">{</span>
                <span class="n">text</span><span class="p">:</span> <span class="s">"</span><span class="se">\0</span><span class="s">"</span><span class="nf">.to_string</span><span class="p">(),</span>
                <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">EOF</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="n">tree</span><span class="p">:</span> <span class="n">ParseTree</span> <span class="p">{</span>
                <span class="n">states</span><span class="p">:</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
                <span class="n">initial_state</span><span class="p">:</span> <span class="s">""</span><span class="nf">.to_string</span><span class="p">(),</span>
                <span class="n">symbols</span><span class="p">:</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
                <span class="n">transitions</span><span class="p">:</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
            <span class="p">},</span>
        <span class="p">};</span>
        <span class="n">parser</span><span class="nf">.next_token</span><span class="p">();</span> <span class="c">// Initialize peek_token</span>
        <span class="n">parser</span><span class="nf">.next_token</span><span class="p">();</span> <span class="c">// Initialize cur_token</span>
        <span class="n">parser</span>
    <span class="p">}</span>

    <span class="c">// Check if the current token matches the expected token type</span>
    <span class="k">fn</span> <span class="nf">check_token</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">kind</span><span class="p">:</span> <span class="n">TokenType</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.cur_token.kind</span> <span class="o">==</span> <span class="n">kind</span>
    <span class="p">}</span>

    <span class="c">// Check if the next token has the expected token type</span>
    <span class="k">fn</span> <span class="nf">check_peek</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">kind</span><span class="p">:</span> <span class="n">TokenType</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.peek_token.kind</span> <span class="o">==</span> <span class="n">kind</span>
    <span class="p">}</span>

    <span class="c">// Advance to the next token</span>
    <span class="k">fn</span> <span class="nf">next_token</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.cur_token</span> <span class="o">=</span> <span class="k">self</span><span class="py">.peek_token</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="k">self</span><span class="py">.peek_token</span> <span class="o">=</span> <span class="k">self</span><span class="py">.lexer</span><span class="nf">.get_token</span><span class="p">()</span><span class="nf">.unwrap_or</span><span class="p">(</span><span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">"</span><span class="se">\0</span><span class="s">"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">EOF</span><span class="p">,</span>
        <span class="p">});</span>

        <span class="c">// If both current and peek token are newline, skip the newline</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.check_token</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">NEWLINE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="k">self</span><span class="nf">.check_peek</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">NEWLINE</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.next_token</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c">// Abort the parsing process with an error message</span>
    <span class="k">fn</span> <span class="nf">abort</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">error!</span><span class="p">(</span><span class="s">"Parsing error: {}"</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>
        <span class="nd">panic!</span><span class="p">(</span><span class="s">"Parsing error: {}"</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c">// Try to consume the current token if it matches the expected token type</span>
    <span class="c">// If successful, print the token type and text (if available) and execute the optional action</span>
    <span class="c">// Return true if the token was consumed, false otherwise</span>
    <span class="k">fn</span> <span class="n">try_consume</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">kind</span><span class="p">:</span> <span class="n">TokenType</span><span class="p">,</span> <span class="n">action</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span>
    <span class="k">where</span>
        <span class="n">F</span><span class="p">:</span> <span class="nf">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">),</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.check_token</span><span class="p">(</span><span class="n">kind</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">match</span> <span class="n">kind</span> <span class="p">{</span>
                <span class="nn">TokenType</span><span class="p">::</span><span class="n">IDENT</span> <span class="k">=&gt;</span> <span class="nd">debug!</span><span class="p">(</span><span class="s">"{:?}: {}"</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="k">self</span><span class="py">.cur_token.text</span><span class="p">),</span>
                <span class="mi">_</span> <span class="k">=&gt;</span> <span class="nd">debug!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">kind</span><span class="p">),</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="k">mut</span> <span class="n">action</span><span class="p">)</span> <span class="o">=</span> <span class="n">action</span> <span class="p">{</span>
                <span class="nf">action</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.cur_token</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">self</span><span class="nf">.next_token</span><span class="p">();</span>
            <span class="k">true</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">false</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c">// Consume the current token if it matches the expected token type</span>
    <span class="c">// If not, abort with an error message</span>
    <span class="c">// Execute the optional action if provided</span>
    <span class="k">fn</span> <span class="n">consume</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">expected</span><span class="p">:</span> <span class="n">TokenType</span><span class="p">,</span> <span class="n">action</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">F</span><span class="p">:</span> <span class="nf">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">),</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="o">!</span><span class="k">self</span><span class="nf">.try_consume</span><span class="p">(</span><span class="n">expected</span><span class="p">,</span> <span class="n">action</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.abort</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">format!</span><span class="p">(</span>
                <span class="s">"Expected {:?}, got {:?}"</span><span class="p">,</span>
                <span class="n">expected</span><span class="p">,</span> <span class="k">self</span><span class="py">.cur_token.kind</span>
            <span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c">// Parse an initial state identifier: [IDENT]</span>
    <span class="k">fn</span> <span class="nf">initial_state_identifier</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">LeftBracket</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">initial_state</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span>
            <span class="nn">TokenType</span><span class="p">::</span><span class="n">IDENT</span><span class="p">,</span>
            <span class="nf">Some</span><span class="p">(|</span><span class="n">token</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Token</span><span class="p">|</span> <span class="p">{</span>
                <span class="n">initial_state</span><span class="nf">.push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="n">token</span><span class="py">.text</span><span class="p">);</span>
            <span class="p">}),</span>
        <span class="p">);</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.tree.initial_state</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.tree.initial_state</span> <span class="o">=</span> <span class="n">initial_state</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="k">self</span><span class="py">.tree.states</span><span class="nf">.push</span><span class="p">(</span><span class="n">initial_state</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.abort</span><span class="p">(</span><span class="s">"Initial state already defined."</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">RightBracket</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>
        <span class="nd">debug!</span><span class="p">(</span><span class="s">"INITIAL_STATE_IDENTIFIER"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c">// Parse a list of state identifiers: IDENT (',' IDENT)*</span>
    <span class="k">fn</span> <span class="nf">state_identifier_list</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">state_identifiers</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

        <span class="c">// Consume all tokens</span>
        <span class="k">while</span> <span class="k">self</span><span class="nf">.check_token</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">IDENT</span><span class="p">)</span> <span class="p">||</span> <span class="k">self</span><span class="nf">.check_token</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">LeftBracket</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">self</span><span class="nf">.check_token</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">LeftBracket</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.initial_state_identifier</span><span class="p">();</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">!</span><span class="k">self</span><span class="nf">.try_consume</span><span class="p">(</span>
                <span class="nn">TokenType</span><span class="p">::</span><span class="n">IDENT</span><span class="p">,</span>
                <span class="nf">Some</span><span class="p">(|</span><span class="n">token</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Token</span><span class="p">|</span> <span class="p">{</span>
                    <span class="n">state_identifiers</span><span class="nf">.push</span><span class="p">(</span><span class="n">token</span><span class="py">.text</span><span class="nf">.clone</span><span class="p">());</span>
                <span class="p">}),</span>
            <span class="p">)</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="o">!</span><span class="k">self</span><span class="nf">.try_consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">COMMA</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
                <span class="nd">debug!</span><span class="p">(</span><span class="s">"STATE_IDENTIFIER_LIST"</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="k">self</span><span class="py">.tree.initial_state</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.abort</span><span class="p">(</span><span class="s">"Initial state not defined."</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c">// If state identifiers have duplicates, abort with an error message</span>
        <span class="n">state_identifiers</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.for_each</span><span class="p">(|</span><span class="n">state_identifier</span><span class="p">|</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">self</span><span class="py">.tree.states</span><span class="nf">.contains</span><span class="p">(</span><span class="n">state_identifier</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.abort</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">format!</span><span class="p">(</span><span class="s">"State {} already defined."</span><span class="p">,</span> <span class="n">state_identifier</span><span class="p">));</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.tree.states</span><span class="nf">.push</span><span class="p">(</span><span class="n">state_identifier</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">});</span>
    <span class="p">}</span>

    <span class="c">// Parse a states declaration: STATES ':' state_identifier_list NEWLINE</span>
    <span class="k">fn</span> <span class="nf">states_declaration</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">STATES</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>
        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">COLON</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>
        <span class="k">self</span><span class="nf">.state_identifier_list</span><span class="p">();</span>
        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">NEWLINE</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>
        <span class="nd">debug!</span><span class="p">(</span><span class="s">"STATES_DECLARATION"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c">// Parse a list of symbol identifiers: IDENT (',' IDENT)*</span>
    <span class="k">fn</span> <span class="nf">symbol_identifiers</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">symbol_identifiers</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span>
            <span class="nn">TokenType</span><span class="p">::</span><span class="n">IDENT</span><span class="p">,</span>
            <span class="nf">Some</span><span class="p">(|</span><span class="n">token</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Token</span><span class="p">|</span> <span class="p">{</span>
                <span class="n">symbol_identifiers</span><span class="nf">.push</span><span class="p">(</span><span class="n">token</span><span class="py">.text</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="p">}),</span>
        <span class="p">);</span>

        <span class="k">while</span> <span class="k">self</span><span class="nf">.try_consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">COMMA</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span>
                <span class="nn">TokenType</span><span class="p">::</span><span class="n">IDENT</span><span class="p">,</span>
                <span class="nf">Some</span><span class="p">(|</span><span class="n">token</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Token</span><span class="p">|</span> <span class="p">{</span>
                    <span class="n">symbol_identifiers</span><span class="nf">.push</span><span class="p">(</span><span class="n">token</span><span class="py">.text</span><span class="nf">.clone</span><span class="p">());</span>
                <span class="p">}),</span>
            <span class="p">);</span>
        <span class="p">}</span>
        <span class="n">symbol_identifiers</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.for_each</span><span class="p">(|</span><span class="n">symbol_identifier</span><span class="p">|</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">self</span><span class="py">.tree.symbols</span><span class="nf">.contains</span><span class="p">(</span><span class="n">symbol_identifier</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.abort</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">format!</span><span class="p">(</span><span class="s">"Symbol {} already defined."</span><span class="p">,</span> <span class="n">symbol_identifier</span><span class="p">));</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.tree.symbols</span><span class="nf">.push</span><span class="p">(</span><span class="n">symbol_identifier</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">});</span>

        <span class="c">// X is a special symbol</span>
        <span class="k">self</span><span class="py">.tree.symbols</span><span class="nf">.push</span><span class="p">(</span><span class="s">"X"</span><span class="nf">.to_string</span><span class="p">());</span>
        <span class="nd">debug!</span><span class="p">(</span><span class="s">"SYMBOL_IDENTIFIERS"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c">// Parse a symbols declaration: SYMBOLS ':' symbol_identifiers NEWLINE</span>
    <span class="k">fn</span> <span class="nf">symbols_declaration</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">SYMBOLS</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>
        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">COLON</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>
        <span class="k">self</span><span class="nf">.symbol_identifiers</span><span class="p">();</span>
        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">NEWLINE</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>
        <span class="nd">debug!</span><span class="p">(</span><span class="s">"SYMBOLS_DECLARATION"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c">// Parse a transition step: R | L | P '(' IDENT ')' | X</span>
    <span class="k">fn</span> <span class="nf">transition_step</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="c">// By default, do nothing</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">step</span><span class="p">:</span> <span class="n">TransitionStep</span> <span class="o">=</span> <span class="nn">TransitionStep</span><span class="p">::</span><span class="n">X</span><span class="p">;</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.try_consume</span><span class="p">(</span>
            <span class="nn">TokenType</span><span class="p">::</span><span class="n">R</span><span class="p">,</span>
            <span class="nf">Some</span><span class="p">(|</span><span class="n">token</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Token</span><span class="p">|</span> <span class="p">{</span>
                <span class="n">step</span> <span class="o">=</span> <span class="nn">FromTokenAndValue</span><span class="p">::</span><span class="nf">from_token_and_value</span><span class="p">(</span><span class="o">&amp;</span><span class="n">token</span><span class="nf">.clone</span><span class="p">(),</span> <span class="nb">None</span><span class="p">);</span>
            <span class="p">}),</span>
        <span class="p">)</span> <span class="p">{</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="k">self</span><span class="nf">.try_consume</span><span class="p">(</span>
            <span class="nn">TokenType</span><span class="p">::</span><span class="n">L</span><span class="p">,</span>
            <span class="nf">Some</span><span class="p">(|</span><span class="n">token</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Token</span><span class="p">|</span> <span class="p">{</span>
                <span class="n">step</span> <span class="o">=</span> <span class="nn">FromTokenAndValue</span><span class="p">::</span><span class="nf">from_token_and_value</span><span class="p">(</span><span class="o">&amp;</span><span class="n">token</span><span class="nf">.clone</span><span class="p">(),</span> <span class="nb">None</span><span class="p">);</span>
            <span class="p">}),</span>
        <span class="p">)</span> <span class="p">{</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="k">self</span><span class="nf">.try_consume</span><span class="p">(</span>
            <span class="nn">TokenType</span><span class="p">::</span><span class="n">X</span><span class="p">,</span>
            <span class="nf">Some</span><span class="p">(|</span><span class="n">token</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Token</span><span class="p">|</span> <span class="p">{</span>
                <span class="n">step</span> <span class="o">=</span> <span class="nn">FromTokenAndValue</span><span class="p">::</span><span class="nf">from_token_and_value</span><span class="p">(</span><span class="o">&amp;</span><span class="n">token</span><span class="nf">.clone</span><span class="p">(),</span> <span class="nb">None</span><span class="p">);</span>
            <span class="p">}),</span>
        <span class="p">)</span> <span class="p">{</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="k">self</span><span class="nf">.try_consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">P</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">LeftParen</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">print_string</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
            <span class="c">// Either X or a symbol identifier</span>
            <span class="k">if</span> <span class="k">self</span><span class="nf">.try_consume</span><span class="p">(</span>
                <span class="nn">TokenType</span><span class="p">::</span><span class="n">X</span><span class="p">,</span>
                <span class="nf">Some</span><span class="p">(|</span><span class="n">token</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Token</span><span class="p">|</span> <span class="p">{</span>
                    <span class="n">print_string</span><span class="nf">.push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="n">token</span><span class="py">.text</span><span class="p">);</span>
                <span class="p">}),</span>
            <span class="p">)</span> <span class="p">{</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span>
                    <span class="nn">TokenType</span><span class="p">::</span><span class="n">IDENT</span><span class="p">,</span>
                    <span class="nf">Some</span><span class="p">(|</span><span class="n">step</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Token</span><span class="p">|</span> <span class="p">{</span>
                        <span class="n">print_string</span><span class="nf">.push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="n">step</span><span class="py">.text</span><span class="p">);</span>
                    <span class="p">}),</span>
                <span class="p">)</span>
            <span class="p">};</span>

            <span class="k">if</span> <span class="o">!</span><span class="k">self</span><span class="py">.tree.symbols</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">print_string</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.abort</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">format!</span><span class="p">(</span>
                    <span class="s">"Symbol {} not defined, So cannot be printed."</span><span class="p">,</span>
                    <span class="n">print_string</span>
                <span class="p">));</span>
            <span class="p">}</span>
            <span class="n">step</span> <span class="o">=</span> <span class="nn">FromTokenAndValue</span><span class="p">::</span><span class="nf">from_token_and_value</span><span class="p">(</span>
                <span class="o">&amp;</span><span class="n">Token</span> <span class="p">{</span>
                    <span class="n">text</span><span class="p">:</span> <span class="s">"P"</span><span class="nf">.to_string</span><span class="p">(),</span>
                    <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">P</span><span class="p">,</span>
                <span class="p">},</span>
                <span class="nf">Some</span><span class="p">(</span><span class="n">print_string</span><span class="p">),</span>
            <span class="p">);</span>

            <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">RightParen</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.abort</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">format!</span><span class="p">(</span>
                <span class="s">"Expected {:?} or {:?} or {:?} or {:?} as an action step, got {:?}: {:?}"</span><span class="p">,</span>
                <span class="nn">TokenType</span><span class="p">::</span><span class="n">R</span><span class="p">,</span>
                <span class="nn">TokenType</span><span class="p">::</span><span class="n">L</span><span class="p">,</span>
                <span class="nn">TokenType</span><span class="p">::</span><span class="n">P</span><span class="p">,</span>
                <span class="nn">TokenType</span><span class="p">::</span><span class="n">X</span><span class="p">,</span>
                <span class="k">self</span><span class="py">.cur_token.kind</span><span class="p">,</span>
                <span class="k">self</span><span class="py">.cur_token.text</span>
            <span class="p">));</span>
        <span class="p">}</span>
        <span class="k">self</span><span class="py">.tree.transitions</span><span class="nf">.last_mut</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.steps</span><span class="nf">.push</span><span class="p">(</span><span class="n">step</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">transition_steps</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.transition_step</span><span class="p">();</span>
        <span class="k">while</span> <span class="k">self</span><span class="nf">.try_consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">DASH</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.transition_step</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="nd">debug!</span><span class="p">(</span><span class="s">"TRANSITION_STEPS"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c">// Parse a list of transition conditions: IDENT ('|' IDENT)*</span>
    <span class="k">fn</span> <span class="nf">transition_condition_list</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">conditions</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

        <span class="c">// Consume X as well</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.try_consume</span><span class="p">(</span>
            <span class="nn">TokenType</span><span class="p">::</span><span class="n">X</span><span class="p">,</span>
            <span class="nf">Some</span><span class="p">(|</span><span class="n">token</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Token</span><span class="p">|</span> <span class="p">{</span>
                <span class="n">conditions</span><span class="nf">.push</span><span class="p">(</span><span class="n">token</span><span class="py">.text</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="p">}),</span>
        <span class="p">)</span> <span class="p">{</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span>
                <span class="nn">TokenType</span><span class="p">::</span><span class="n">IDENT</span><span class="p">,</span>
                <span class="nf">Some</span><span class="p">(|</span><span class="n">token</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Token</span><span class="p">|</span> <span class="p">{</span>
                    <span class="n">conditions</span><span class="nf">.push</span><span class="p">(</span><span class="n">token</span><span class="py">.text</span><span class="nf">.clone</span><span class="p">());</span>
                <span class="p">}),</span>
            <span class="p">);</span>
        <span class="p">}</span>

        <span class="k">while</span> <span class="k">self</span><span class="nf">.try_consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">OR</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
            <span class="c">// Consume X as well</span>
            <span class="k">if</span> <span class="k">self</span><span class="nf">.try_consume</span><span class="p">(</span>
                <span class="nn">TokenType</span><span class="p">::</span><span class="n">X</span><span class="p">,</span>
                <span class="nf">Some</span><span class="p">(|</span><span class="n">token</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Token</span><span class="p">|</span> <span class="p">{</span>
                    <span class="n">conditions</span><span class="nf">.push</span><span class="p">(</span><span class="n">token</span><span class="py">.text</span><span class="nf">.clone</span><span class="p">());</span>
                <span class="p">}),</span>
            <span class="p">)</span> <span class="p">{</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span>
                    <span class="nn">TokenType</span><span class="p">::</span><span class="n">IDENT</span><span class="p">,</span>
                    <span class="nf">Some</span><span class="p">(|</span><span class="n">token</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Token</span><span class="p">|</span> <span class="p">{</span>
                        <span class="n">conditions</span><span class="nf">.push</span><span class="p">(</span><span class="n">token</span><span class="py">.text</span><span class="nf">.clone</span><span class="p">());</span>
                    <span class="p">}),</span>
                <span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">self</span><span class="py">.tree.transitions</span><span class="nf">.last_mut</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.condition</span> <span class="o">=</span> <span class="nn">Condition</span><span class="p">::</span><span class="nf">OR</span><span class="p">(</span><span class="n">conditions</span><span class="p">);</span>
        <span class="nd">debug!</span><span class="p">(</span><span class="s">"TRANSITION_CONDITION_LIST"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c">// Parse transition conditions: '*' | transition_condition_list</span>
    <span class="k">fn</span> <span class="nf">transition_conditions</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">star_condition</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>
        <span class="k">if</span> <span class="o">!</span><span class="k">self</span><span class="nf">.try_consume</span><span class="p">(</span>
            <span class="nn">TokenType</span><span class="p">::</span><span class="n">STAR</span><span class="p">,</span>
            <span class="nf">Some</span><span class="p">(|</span><span class="mi">_</span><span class="n">token</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Token</span><span class="p">|</span> <span class="p">{</span>
                <span class="n">star_condition</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">}),</span>
        <span class="p">)</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.transition_condition_list</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="c">// Override all other conditions with the star condition</span>
        <span class="k">if</span> <span class="n">star_condition</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.tree.transitions</span><span class="nf">.last_mut</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.condition</span> <span class="o">=</span> <span class="nn">Condition</span><span class="p">::</span><span class="n">Star</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nd">debug!</span><span class="p">(</span><span class="s">"TRANSITION_CONDITIONS"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c">// Parse a transition declaration:</span>
    <span class="c">// IDENT ',' transition_conditions ',' transition_steps ',' IDENT</span>
    <span class="k">fn</span> <span class="nf">transition_declaration</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="c">// Initialize a new transition</span>
        <span class="k">self</span><span class="py">.tree.transitions</span><span class="nf">.push</span><span class="p">(</span><span class="nn">Transition</span><span class="p">::</span><span class="nf">new</span><span class="p">());</span>

        <span class="c">// Initial state</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">initial_state</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span>
            <span class="nn">TokenType</span><span class="p">::</span><span class="n">IDENT</span><span class="p">,</span>
            <span class="nf">Some</span><span class="p">(|</span><span class="n">token</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Token</span><span class="p">|</span> <span class="p">{</span>
                <span class="n">initial_state</span><span class="nf">.push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="n">token</span><span class="py">.text</span><span class="p">);</span>
            <span class="p">}),</span>
        <span class="p">);</span>
        <span class="k">self</span><span class="py">.tree.transitions</span><span class="nf">.last_mut</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.initial_state</span> <span class="o">=</span> <span class="n">initial_state</span><span class="p">;</span>

        <span class="nd">debug!</span><span class="p">(</span><span class="s">"INITIAL_STATE_IDENTIFIER"</span><span class="p">);</span>
        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">COMMA</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>

        <span class="c">// Conditions</span>
        <span class="k">self</span><span class="nf">.transition_conditions</span><span class="p">();</span>
        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">COMMA</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>

        <span class="c">// Actions</span>
        <span class="k">self</span><span class="nf">.transition_steps</span><span class="p">();</span>
        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">COMMA</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>

        <span class="c">// Final state</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">final_state</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span>
            <span class="nn">TokenType</span><span class="p">::</span><span class="n">IDENT</span><span class="p">,</span>
            <span class="nf">Some</span><span class="p">(|</span><span class="n">token</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Token</span><span class="p">|</span> <span class="p">{</span>
                <span class="n">final_state</span><span class="nf">.push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="n">token</span><span class="py">.text</span><span class="p">);</span>
            <span class="p">}),</span>
        <span class="p">);</span>
        <span class="k">self</span><span class="py">.tree.transitions</span><span class="nf">.last_mut</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.final_state</span> <span class="o">=</span> <span class="n">final_state</span><span class="p">;</span>
        <span class="nd">debug!</span><span class="p">(</span><span class="s">"FINAL_STATE_IDENTIFIER"</span><span class="p">);</span>
        <span class="nd">debug!</span><span class="p">(</span><span class="s">"TRANSITION_DECLARATION"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c">// Parse transitions declarations:</span>
    <span class="c">// TRANSITIONS ':' (NEWLINE transition_declaration)*</span>
    <span class="k">fn</span> <span class="nf">transitions_declaration</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">TRANSITIONS</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>
        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">COLON</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>

        <span class="k">while</span> <span class="k">self</span><span class="nf">.try_consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">NEWLINE</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">self</span><span class="nf">.check_token</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">EOF</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">self</span><span class="nf">.transition_declaration</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="nd">debug!</span><span class="p">(</span><span class="s">"TRANSITION_DECLARATIONS"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c">// Parse the entire program:</span>
    <span class="c">// NEWLINE? states_declaration symbols_declaration transitions_declaration NEWLINE? EOF</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">program</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="c">// Consume newlines</span>
        <span class="k">while</span> <span class="k">self</span><span class="nf">.try_consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">NEWLINE</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{}</span>
        <span class="k">self</span><span class="nf">.states_declaration</span><span class="p">();</span>
        <span class="k">self</span><span class="nf">.symbols_declaration</span><span class="p">();</span>
        <span class="k">self</span><span class="nf">.transitions_declaration</span><span class="p">();</span>
        <span class="c">// Consume newlines</span>
        <span class="k">while</span> <span class="k">self</span><span class="nf">.try_consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">NEWLINE</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{}</span>
        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">EOF</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>
        <span class="nd">debug!</span><span class="p">(</span><span class="s">"PROGRAM"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>


</details>

<h2 id="generating-rust-code">Generating Rust code</h2>

<p>Once we have parsed the specification, generating the rust code is just a matter of substituting the right values in the template.</p>

<p>Let’s take a look at the template:</p>

<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">fmt</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">io</span><span class="p">;</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq)]</span>
<span class="k">enum</span> <span class="n">TapeMachineState</span> <span class="p">{</span>
    <span class="c">// FILL IN THE STATES FROM THE PARSE TREE</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq,</span> <span class="nd">Clone)]</span>
<span class="k">enum</span> <span class="n">TapeMachineSymbol</span> <span class="p">{</span>
    <span class="c">// FILL IN THE SYMBOLS FROM THE PARSE TREE</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">TapeMachineSymbol</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">as_str</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'static</span> <span class="nb">str</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
            <span class="c">// FILL IN THE MATCH ARMS FOR EACH SYMBOL</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">TapeMachine</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">state</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">TapeMachineState</span><span class="p">,</span>
    <span class="n">result</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">TapeMachineSymbol</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">index</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">TapeMachine</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">state</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">TapeMachineState</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">TapeMachineSymbol</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
        <span class="n">Self</span> <span class="p">{</span>
            <span class="n">state</span><span class="p">,</span>
            <span class="n">result</span><span class="p">,</span>
            <span class="n">index</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">p</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">symbol</span><span class="p">:</span> <span class="n">TapeMachineSymbol</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.result</span><span class="p">[</span><span class="k">self</span><span class="py">.index</span><span class="p">]</span> <span class="o">=</span> <span class="n">symbol</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">r</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.index</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">l</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.index</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Enter the number of steps:"</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">steps_input</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="nn">io</span><span class="p">::</span><span class="nf">stdin</span><span class="p">()</span><span class="nf">.read_line</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">steps_input</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">steps</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="n">steps_input</span><span class="nf">.trim</span><span class="p">()</span><span class="nf">.parse</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"Enter the total tape length:"</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">tape_length_input</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="nn">io</span><span class="p">::</span><span class="nf">stdin</span><span class="p">()</span><span class="nf">.read_line</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">tape_length_input</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">max_len</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="n">tape_length_input</span><span class="nf">.trim</span><span class="p">()</span><span class="nf">.parse</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">result</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="nn">TapeMachineSymbol</span><span class="p">::</span><span class="n">SymbolX</span><span class="p">;</span> <span class="n">max_len</span><span class="p">];</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">tape_machine</span> <span class="o">=</span> <span class="nn">TapeMachine</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="nn">TapeMachineState</span><span class="p">::</span><span class="cm">/* FILL IN THE INITIAL STATE */</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">result</span><span class="p">);</span>

    <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">steps</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Step: {} State: {:?} Symbol: {:?}"</span><span class="p">,</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">tape_machine</span><span class="py">.state</span><span class="p">,</span> <span class="n">tape_machine</span><span class="py">.result</span><span class="p">[</span><span class="n">tape_machine</span><span class="py">.index</span><span class="p">]);</span>

        <span class="k">match</span> <span class="p">(</span><span class="n">tape_machine</span><span class="py">.state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tape_machine</span><span class="py">.result</span><span class="p">[</span><span class="n">tape_machine</span><span class="py">.index</span><span class="p">])</span> <span class="p">{</span>
            <span class="c">// FILL IN THE MATCH ARMS FOR EACH TRANSITION</span>
            <span class="p">(</span><span class="mi">_</span><span class="p">,</span> <span class="mi">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"State: {:?} Index: {:?} Symbol: {:?}"</span><span class="p">,</span> <span class="n">tape_machine</span><span class="py">.state</span><span class="p">,</span> <span class="n">tape_machine</span><span class="py">.index</span><span class="p">,</span> <span class="n">tape_machine</span><span class="py">.result</span><span class="p">[</span><span class="n">tape_machine</span><span class="py">.index</span><span class="p">]);</span>
                <span class="k">let</span> <span class="n">binary_result</span><span class="p">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="n">tape_machine</span><span class="py">.result</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="nf">.as_str</span><span class="p">())</span><span class="nf">.collect</span><span class="p">();</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">binary_result</span><span class="p">);</span>
                <span class="nd">panic!</span><span class="p">(</span><span class="s">"Invalid state reached"</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">binary_result</span><span class="p">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="n">tape_machine</span><span class="py">.result</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="nf">.as_str</span><span class="p">())</span><span class="nf">.collect</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">binary_result</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">clean_result</span><span class="p">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="n">tape_machine</span><span class="py">.result</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.filter</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="nn">TapeMachineSymbol</span><span class="p">::</span><span class="n">SymbolX</span><span class="p">)</span><span class="nf">.map</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="nf">.as_str</span><span class="p">())</span><span class="nf">.collect</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"=========</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">clean_result</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>The code to do this is pretty straightforward, take a look below:</p>

<details>
<summary>Full Rust Code Generator</summary>


<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span> <span class="n">ParseTree</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">to_rust_code</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">code</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

        <span class="c">// Generate the TapeMachineState enum</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span>
            <span class="s">"use std::fmt;</span><span class="se">\n</span><span class="s">use std::io;</span><span class="se">\n\n</span><span class="s">#[derive(Debug, PartialEq, Eq)]</span><span class="se">\n</span><span class="s">enum TapeMachineState {</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
        <span class="p">);</span>
        <span class="k">for</span> <span class="n">state</span> <span class="n">in</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.states</span> <span class="p">{</span>
            <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">format!</span><span class="p">(</span><span class="s">"    {},</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">state</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"}</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>

        <span class="c">// Generate the TapeMachineSymbol enum</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"#[derive(Debug, PartialEq, Eq, Clone)]</span><span class="se">\n</span><span class="s">enum TapeMachineSymbol {</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">for</span> <span class="n">symbol</span> <span class="n">in</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.symbols</span> <span class="p">{</span>
            <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">format!</span><span class="p">(</span><span class="s">"    Symbol{},</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">symbol</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"}</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>

        <span class="c">// Generate the TapeMachineSymbol implementation</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"impl TapeMachineSymbol {</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    fn as_str(&amp;self) -&gt; &amp;'static str {</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"        match self {</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span>
            <span class="o">&amp;</span><span class="k">self</span>
                <span class="py">.symbols</span>
                <span class="nf">.iter</span><span class="p">()</span>
                <span class="nf">.map</span><span class="p">(|</span><span class="n">symbol</span><span class="p">|</span> <span class="p">{</span>
                    <span class="nd">format!</span><span class="p">(</span>
                        <span class="s">"            TapeMachineSymbol::Symbol{} =&gt; </span><span class="se">\"</span><span class="s">{}</span><span class="se">\"</span><span class="s">"</span><span class="p">,</span>
                        <span class="n">symbol</span><span class="p">,</span> <span class="n">symbol</span>
                    <span class="p">)</span>
                <span class="p">})</span>
                <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;&gt;</span><span class="p">()</span>
                <span class="nf">.join</span><span class="p">(</span><span class="s">",</span><span class="se">\n</span><span class="s">"</span><span class="p">),</span>
        <span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">        }</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    }</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"}</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>

        <span class="c">// Generate the TapeMachine struct</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"struct TapeMachine&lt;'a&gt; {</span><span class="se">\n</span><span class="s">    state: &amp;'a TapeMachineState,</span><span class="se">\n</span><span class="s">    result: &amp;'a mut Vec&lt;TapeMachineSymbol&gt;,</span><span class="se">\n</span><span class="s">    index: usize,</span><span class="se">\n</span><span class="s">}</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>

        <span class="c">// Generate the TapeMachine implementation</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"impl&lt;'a&gt; TapeMachine&lt;'a&gt; {</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    pub fn new(state: &amp;'a TapeMachineState, result: &amp;'a mut Vec&lt;TapeMachineSymbol&gt;) -&gt; Self {</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"        Self {</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"            state,</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"            result,</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"            index: 0,</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"        }</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    }</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>

        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    fn p(&amp;mut self, symbol: TapeMachineSymbol) {</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"        self.result[self.index] = symbol;</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    }</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>

        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    fn r(&amp;mut self) {</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"        self.index += 1;</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    }</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>

        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    fn l(&amp;mut self) {</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"        self.index -= 1;</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    }</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"}</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>

        <span class="c">// Generate the main function</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"fn main() {</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    println!(</span><span class="se">\"</span><span class="s">Enter the number of steps:</span><span class="se">\"</span><span class="s">);</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    let mut steps_input = String::new();</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    io::stdin().read_line(&amp;mut steps_input).unwrap();</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    let steps: usize = steps_input.trim().parse().unwrap();</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>

        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    println!(</span><span class="se">\"</span><span class="s">Enter the total tape length:</span><span class="se">\"</span><span class="s">);</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    let mut tape_length_input = String::new();</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    io::stdin().read_line(&amp;mut tape_length_input).unwrap();</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    let max_len: usize = tape_length_input.trim().parse().unwrap();</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    let mut result = vec![TapeMachineSymbol::SymbolX; max_len];</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">format!</span><span class="p">(</span>
            <span class="s">"    let mut tape_machine = TapeMachine::new(&amp;TapeMachineState::{}, &amp;mut result);</span><span class="se">\n\n</span><span class="s">"</span><span class="p">,</span>
            <span class="k">self</span><span class="py">.initial_state</span>
        <span class="p">));</span>

        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    for i in 0..steps {</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"        println!(</span><span class="se">\"</span><span class="s">Step: {} State: {:?} Symbol: {:?}</span><span class="se">\"</span><span class="s">,</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span>
            <span class="s">"            i, tape_machine.state, tape_machine.result[tape_machine.index]);</span><span class="se">\n\n</span><span class="s">"</span><span class="p">,</span>
        <span class="p">);</span>

        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span>
            <span class="s">"        match (tape_machine.state, &amp;tape_machine.result[tape_machine.index]) {</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
        <span class="p">);</span>

        <span class="c">// Sort transitions so that the ones with star condition are executed last</span>
        <span class="c">// This is to ensure compatibility with switch statements</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">sorted_transitions</span> <span class="o">=</span> <span class="k">self</span><span class="py">.transitions</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="n">sorted_transitions</span><span class="nf">.sort_by</span><span class="p">(|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">|</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">a</span><span class="py">.condition</span> <span class="o">==</span> <span class="nn">Condition</span><span class="p">::</span><span class="n">Star</span> <span class="p">{</span>
                <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nn">Ordering</span><span class="p">::</span><span class="n">Greater</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">b</span><span class="py">.condition</span> <span class="o">==</span> <span class="nn">Condition</span><span class="p">::</span><span class="n">Star</span> <span class="p">{</span>
                <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nn">Ordering</span><span class="p">::</span><span class="n">Less</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nn">Ordering</span><span class="p">::</span><span class="n">Equal</span>
            <span class="p">}</span>
        <span class="p">});</span>
        <span class="k">for</span> <span class="n">transition</span> <span class="n">in</span> <span class="n">sorted_transitions</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">condition</span> <span class="o">=</span> <span class="k">match</span> <span class="o">&amp;</span><span class="n">transition</span><span class="py">.condition</span> <span class="p">{</span>
                <span class="nn">Condition</span><span class="p">::</span><span class="nf">OR</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="k">mut</span> <span class="n">condition_str</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
                    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">symbol</span><span class="p">)</span> <span class="n">in</span> <span class="n">symbols</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
                        <span class="n">condition_str</span><span class="nf">.push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">format!</span><span class="p">(</span><span class="s">"TapeMachineSymbol::Symbol{}"</span><span class="p">,</span> <span class="n">symbol</span><span class="p">));</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">symbols</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
                            <span class="n">condition_str</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">" | "</span><span class="p">);</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                    <span class="n">condition_str</span>
                <span class="p">}</span>
                <span class="nn">Condition</span><span class="p">::</span><span class="n">Star</span> <span class="k">=&gt;</span> <span class="s">"_"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="p">};</span>

            <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">format!</span><span class="p">(</span>
                <span class="s">"            (TapeMachineState::{}, {}) =&gt; "</span><span class="p">,</span>
                <span class="n">transition</span><span class="py">.initial_state</span><span class="p">,</span> <span class="n">condition</span>
            <span class="p">));</span>
            <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"{</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

            <span class="k">for</span> <span class="n">step</span> <span class="n">in</span> <span class="o">&amp;</span><span class="n">transition</span><span class="py">.steps</span> <span class="p">{</span>
                <span class="k">match</span> <span class="n">step</span> <span class="p">{</span>
                    <span class="nn">TransitionStep</span><span class="p">::</span><span class="n">R</span> <span class="k">=&gt;</span> <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"                tape_machine.r();</span><span class="se">\n</span><span class="s">"</span><span class="p">),</span>
                    <span class="nn">TransitionStep</span><span class="p">::</span><span class="n">L</span> <span class="k">=&gt;</span> <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"                tape_machine.l();</span><span class="se">\n</span><span class="s">"</span><span class="p">),</span>
                    <span class="nn">TransitionStep</span><span class="p">::</span><span class="n">X</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"                // X means do nothing</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
                    <span class="p">}</span>
                    <span class="nn">TransitionStep</span><span class="p">::</span><span class="nf">P</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">format!</span><span class="p">(</span>
                            <span class="s">"                tape_machine.p(TapeMachineSymbol::Symbol{});</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                            <span class="n">symbol</span>
                        <span class="p">));</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">format!</span><span class="p">(</span>
                <span class="s">"                tape_machine.state = &amp;TapeMachineState::{};</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                <span class="n">transition</span><span class="py">.final_state</span>
            <span class="p">));</span>
            <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">format!</span><span class="p">(</span>
                <span class="s">"                println!(</span><span class="se">\"</span><span class="s">Final State: </span><span class="se">\"</span><span class="s">, TapeMachineState::{});</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                <span class="n">transition</span><span class="py">.final_state</span>
            <span class="p">));</span>
            <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"            }</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"            (_, _) =&gt; {</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"                println!(</span><span class="se">\"</span><span class="s">State: {:?} Index: {:?} Symbol: {:?}</span><span class="se">\"</span><span class="s">, tape_machine.state, tape_machine.index, tape_machine.result[tape_machine.index]);</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"                let binary_result: String = tape_machine.result.iter().map(|x| x.as_str()).collect();</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"                println!(</span><span class="se">\"</span><span class="s">{}</span><span class="se">\"</span><span class="s">, binary_result);</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"                panic!(</span><span class="se">\"</span><span class="s">Invalid state reached</span><span class="se">\"</span><span class="s">);</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"            }</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"        }</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    }</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>

        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    let binary_result: String = tape_machine.result.iter().map(|x| x.as_str()).collect();</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    println!(</span><span class="se">\"</span><span class="s">{}</span><span class="se">\"</span><span class="s">, binary_result);</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    let clean_result: String = tape_machine.result.iter().filter( |&amp;x| x != &amp;TapeMachineSymbol::SymbolX).map(|x| x.as_str()).collect();</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    println!(</span><span class="se">\"</span><span class="s">=========</span><span class="se">\\</span><span class="s">n</span><span class="se">\"</span><span class="s">);</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    println!(</span><span class="se">\"</span><span class="s">{}</span><span class="se">\"</span><span class="s">, clean_result);</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"}</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

        <span class="n">code</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>


</details>

<p>This completes our implementation end to end. Take a look at the full code, for
few extra bells and whistles, like generating the dot file for the state machine
etc.</p>

<details>
<summary>Full Rust Code</summary>


<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
482
483
484
485
486
487
488
489
490
491
492
493
494
495
496
497
498
499
500
501
502
503
504
505
506
507
508
509
510
511
512
513
514
515
516
517
518
519
520
521
522
523
524
525
526
527
528
529
530
531
532
533
534
535
536
537
538
539
540
541
542
543
544
545
546
547
548
549
550
551
552
553
554
555
556
557
558
559
560
561
562
563
564
565
566
567
568
569
570
571
572
573
574
575
576
577
578
579
580
581
582
583
584
585
586
587
588
589
590
591
592
593
594
595
596
597
598
599
600
601
602
603
604
605
606
607
608
609
610
611
612
613
614
615
616
617
618
619
620
621
622
623
624
625
626
627
628
629
630
631
632
633
634
635
636
637
638
639
640
641
642
643
644
645
646
647
648
649
650
651
652
653
654
655
656
657
658
659
660
661
662
663
664
665
666
667
668
669
670
671
672
673
674
675
676
677
678
679
680
681
682
683
684
685
686
687
688
689
690
691
692
693
694
695
696
697
698
699
700
701
702
703
704
705
706
707
708
709
710
711
712
713
714
715
716
717
718
719
720
721
722
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">crate</span><span class="p">::</span><span class="nn">lexer</span><span class="p">::{</span><span class="n">Lexer</span><span class="p">,</span> <span class="n">Token</span><span class="p">,</span> <span class="n">TokenType</span><span class="p">};</span>
<span class="k">use</span> <span class="k">log</span><span class="p">::{</span><span class="n">debug</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">info</span><span class="p">};</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">Condition</span> <span class="p">{</span>
    <span class="nf">OR</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">),</span>
    <span class="n">Star</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">TransitionStep</span> <span class="p">{</span>
    <span class="n">R</span><span class="p">,</span>
    <span class="n">L</span><span class="p">,</span>
    <span class="n">X</span><span class="p">,</span>
    <span class="nf">P</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span> <span class="c">// A function call</span>
<span class="p">}</span>

<span class="k">trait</span> <span class="n">FromTokenAndValue</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">from_token_and_value</span><span class="p">(</span><span class="n">token</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Token</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Self</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">FromTokenAndValue</span> <span class="k">for</span> <span class="n">TransitionStep</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">from_token_and_value</span><span class="p">(</span><span class="n">token</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Token</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">token</span><span class="py">.kind</span> <span class="p">{</span>
            <span class="nn">TokenType</span><span class="p">::</span><span class="n">R</span> <span class="k">=&gt;</span> <span class="nn">TransitionStep</span><span class="p">::</span><span class="n">R</span><span class="p">,</span>
            <span class="nn">TokenType</span><span class="p">::</span><span class="n">L</span> <span class="k">=&gt;</span> <span class="nn">TransitionStep</span><span class="p">::</span><span class="n">L</span><span class="p">,</span>
            <span class="nn">TokenType</span><span class="p">::</span><span class="n">X</span> <span class="k">=&gt;</span> <span class="nn">TransitionStep</span><span class="p">::</span><span class="n">X</span><span class="p">,</span>
            <span class="nn">TokenType</span><span class="p">::</span><span class="n">P</span> <span class="k">=&gt;</span> <span class="nn">TransitionStep</span><span class="p">::</span><span class="nf">P</span><span class="p">(</span><span class="n">value</span><span class="nf">.unwrap</span><span class="p">()),</span>
            <span class="mi">_</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"Invalid token type for TransitionStep"</span><span class="p">),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Transition</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">initial_state</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">condition</span><span class="p">:</span> <span class="n">Condition</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">steps</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">TransitionStep</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">final_state</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Transition</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
        <span class="n">Transition</span> <span class="p">{</span>
            <span class="n">initial_state</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
            <span class="n">condition</span><span class="p">:</span> <span class="nn">Condition</span><span class="p">::</span><span class="nf">OR</span><span class="p">(</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">()),</span>
            <span class="n">steps</span><span class="p">:</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
            <span class="n">final_state</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">ParseTree</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">states</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">initial_state</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">symbols</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">transitions</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Transition</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">ParseTree</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">to_rust_code</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">code</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

        <span class="c">// Generate the TapeMachineState enum</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span>
            <span class="s">"use std::fmt;</span><span class="se">\n</span><span class="s">use std::io;</span><span class="se">\n\n</span><span class="s">#[derive(Debug, PartialEq, Eq)]</span><span class="se">\n</span><span class="s">enum TapeMachineState {</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
        <span class="p">);</span>
        <span class="k">for</span> <span class="n">state</span> <span class="n">in</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.states</span> <span class="p">{</span>
            <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">format!</span><span class="p">(</span><span class="s">"    {},</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">state</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"}</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>

        <span class="c">// Generate the TapeMachineSymbol enum</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"#[derive(Debug, PartialEq, Eq, Clone)]</span><span class="se">\n</span><span class="s">enum TapeMachineSymbol {</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">for</span> <span class="n">symbol</span> <span class="n">in</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.symbols</span> <span class="p">{</span>
            <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">format!</span><span class="p">(</span><span class="s">"    Symbol{},</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">symbol</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"}</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>

        <span class="c">// Generate the TapeMachineSymbol implementation</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"impl TapeMachineSymbol {</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    fn as_str(&amp;self) -&gt; &amp;'static str {</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"        match self {</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span>
            <span class="o">&amp;</span><span class="k">self</span>
                <span class="py">.symbols</span>
                <span class="nf">.iter</span><span class="p">()</span>
                <span class="nf">.map</span><span class="p">(|</span><span class="n">symbol</span><span class="p">|</span> <span class="p">{</span>
                    <span class="nd">format!</span><span class="p">(</span>
                        <span class="s">"            TapeMachineSymbol::Symbol{} =&gt; </span><span class="se">\"</span><span class="s">{}</span><span class="se">\"</span><span class="s">"</span><span class="p">,</span>
                        <span class="n">symbol</span><span class="p">,</span> <span class="n">symbol</span>
                    <span class="p">)</span>
                <span class="p">})</span>
                <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;&gt;</span><span class="p">()</span>
                <span class="nf">.join</span><span class="p">(</span><span class="s">",</span><span class="se">\n</span><span class="s">"</span><span class="p">),</span>
        <span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">        }</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    }</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"}</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>

        <span class="c">// Generate the TapeMachine struct</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"struct TapeMachine&lt;'a&gt; {</span><span class="se">\n</span><span class="s">    state: &amp;'a TapeMachineState,</span><span class="se">\n</span><span class="s">    result: &amp;'a mut Vec&lt;TapeMachineSymbol&gt;,</span><span class="se">\n</span><span class="s">    index: usize,</span><span class="se">\n</span><span class="s">}</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>

        <span class="c">// Generate the TapeMachine implementation</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"impl&lt;'a&gt; TapeMachine&lt;'a&gt; {</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    pub fn new(state: &amp;'a TapeMachineState, result: &amp;'a mut Vec&lt;TapeMachineSymbol&gt;) -&gt; Self {</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"        Self {</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"            state,</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"            result,</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"            index: 0,</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"        }</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    }</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>

        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    fn p(&amp;mut self, symbol: TapeMachineSymbol) {</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"        self.result[self.index] = symbol;</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    }</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>

        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    fn r(&amp;mut self) {</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"        self.index += 1;</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    }</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>

        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    fn l(&amp;mut self) {</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"        self.index -= 1;</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    }</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"}</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>

        <span class="c">// Generate the main function</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"fn main() {</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    println!(</span><span class="se">\"</span><span class="s">Enter the number of steps:</span><span class="se">\"</span><span class="s">);</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    let mut steps_input = String::new();</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    io::stdin().read_line(&amp;mut steps_input).unwrap();</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    let steps: usize = steps_input.trim().parse().unwrap();</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>

        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    println!(</span><span class="se">\"</span><span class="s">Enter the total tape length:</span><span class="se">\"</span><span class="s">);</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    let mut tape_length_input = String::new();</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    io::stdin().read_line(&amp;mut tape_length_input).unwrap();</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    let max_len: usize = tape_length_input.trim().parse().unwrap();</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    let mut result = vec![TapeMachineSymbol::SymbolX; max_len];</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">format!</span><span class="p">(</span>
            <span class="s">"    let mut tape_machine = TapeMachine::new(&amp;TapeMachineState::{}, &amp;mut result);</span><span class="se">\n\n</span><span class="s">"</span><span class="p">,</span>
            <span class="k">self</span><span class="py">.initial_state</span>
        <span class="p">));</span>

        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    for i in 0..steps {</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"        println!(</span><span class="se">\"</span><span class="s">Step: {} State: {:?} Symbol: {:?}</span><span class="se">\"</span><span class="s">,</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span>
            <span class="s">"            i, tape_machine.state, tape_machine.result[tape_machine.index]);</span><span class="se">\n\n</span><span class="s">"</span><span class="p">,</span>
        <span class="p">);</span>

        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span>
            <span class="s">"        match (tape_machine.state, &amp;tape_machine.result[tape_machine.index]) {</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
        <span class="p">);</span>

        <span class="c">// Sort transitions so that the ones with star condition are executed last</span>
        <span class="c">// This is to ensure compatibility with switch statements</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">sorted_transitions</span> <span class="o">=</span> <span class="k">self</span><span class="py">.transitions</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="n">sorted_transitions</span><span class="nf">.sort_by</span><span class="p">(|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">|</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">a</span><span class="py">.condition</span> <span class="o">==</span> <span class="nn">Condition</span><span class="p">::</span><span class="n">Star</span> <span class="p">{</span>
                <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nn">Ordering</span><span class="p">::</span><span class="n">Greater</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">b</span><span class="py">.condition</span> <span class="o">==</span> <span class="nn">Condition</span><span class="p">::</span><span class="n">Star</span> <span class="p">{</span>
                <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nn">Ordering</span><span class="p">::</span><span class="n">Less</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nn">Ordering</span><span class="p">::</span><span class="n">Equal</span>
            <span class="p">}</span>
        <span class="p">});</span>
        <span class="k">for</span> <span class="n">transition</span> <span class="n">in</span> <span class="n">sorted_transitions</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">condition</span> <span class="o">=</span> <span class="k">match</span> <span class="o">&amp;</span><span class="n">transition</span><span class="py">.condition</span> <span class="p">{</span>
                <span class="nn">Condition</span><span class="p">::</span><span class="nf">OR</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="k">mut</span> <span class="n">condition_str</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
                    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">symbol</span><span class="p">)</span> <span class="n">in</span> <span class="n">symbols</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
                        <span class="n">condition_str</span><span class="nf">.push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">format!</span><span class="p">(</span><span class="s">"TapeMachineSymbol::Symbol{}"</span><span class="p">,</span> <span class="n">symbol</span><span class="p">));</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">symbols</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
                            <span class="n">condition_str</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">" | "</span><span class="p">);</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                    <span class="n">condition_str</span>
                <span class="p">}</span>
                <span class="nn">Condition</span><span class="p">::</span><span class="n">Star</span> <span class="k">=&gt;</span> <span class="s">"_"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="p">};</span>

            <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">format!</span><span class="p">(</span>
                <span class="s">"            (TapeMachineState::{}, {}) =&gt; "</span><span class="p">,</span>
                <span class="n">transition</span><span class="py">.initial_state</span><span class="p">,</span> <span class="n">condition</span>
            <span class="p">));</span>
            <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"{</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

            <span class="k">for</span> <span class="n">step</span> <span class="n">in</span> <span class="o">&amp;</span><span class="n">transition</span><span class="py">.steps</span> <span class="p">{</span>
                <span class="k">match</span> <span class="n">step</span> <span class="p">{</span>
                    <span class="nn">TransitionStep</span><span class="p">::</span><span class="n">R</span> <span class="k">=&gt;</span> <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"                tape_machine.r();</span><span class="se">\n</span><span class="s">"</span><span class="p">),</span>
                    <span class="nn">TransitionStep</span><span class="p">::</span><span class="n">L</span> <span class="k">=&gt;</span> <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"                tape_machine.l();</span><span class="se">\n</span><span class="s">"</span><span class="p">),</span>
                    <span class="nn">TransitionStep</span><span class="p">::</span><span class="n">X</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"                // X means do nothing</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
                    <span class="p">}</span>
                    <span class="nn">TransitionStep</span><span class="p">::</span><span class="nf">P</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">format!</span><span class="p">(</span>
                            <span class="s">"                tape_machine.p(TapeMachineSymbol::Symbol{});</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                            <span class="n">symbol</span>
                        <span class="p">));</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">format!</span><span class="p">(</span>
                <span class="s">"                tape_machine.state = &amp;TapeMachineState::{};</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                <span class="n">transition</span><span class="py">.final_state</span>
            <span class="p">));</span>
            <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">format!</span><span class="p">(</span>
                <span class="s">"                println!(</span><span class="se">\"</span><span class="s">Final State: </span><span class="se">\"</span><span class="s">, TapeMachineState::{});</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                <span class="n">transition</span><span class="py">.final_state</span>
            <span class="p">));</span>
            <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"            }</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"            (_, _) =&gt; {</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"                println!(</span><span class="se">\"</span><span class="s">State: {:?} Index: {:?} Symbol: {:?}</span><span class="se">\"</span><span class="s">, tape_machine.state, tape_machine.index, tape_machine.result[tape_machine.index]);</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"                let binary_result: String = tape_machine.result.iter().map(|x| x.as_str()).collect();</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"                println!(</span><span class="se">\"</span><span class="s">{}</span><span class="se">\"</span><span class="s">, binary_result);</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"                panic!(</span><span class="se">\"</span><span class="s">Invalid state reached</span><span class="se">\"</span><span class="s">);</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"            }</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"        }</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    }</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>

        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    let binary_result: String = tape_machine.result.iter().map(|x| x.as_str()).collect();</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    println!(</span><span class="se">\"</span><span class="s">{}</span><span class="se">\"</span><span class="s">, binary_result);</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    let clean_result: String = tape_machine.result.iter().filter( |&amp;x| x != &amp;TapeMachineSymbol::SymbolX).map(|x| x.as_str()).collect();</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    println!(</span><span class="se">\"</span><span class="s">=========</span><span class="se">\\</span><span class="s">n</span><span class="se">\"</span><span class="s">);</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"    println!(</span><span class="se">\"</span><span class="s">{}</span><span class="se">\"</span><span class="s">, clean_result);</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">code</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"}</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

        <span class="n">code</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">pub</span> <span class="k">trait</span> <span class="n">ToDot</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">to_dot</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">ToDot</span> <span class="k">for</span> <span class="n">ParseTree</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">to_dot</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">dot</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span>
            <span class="s">"digraph {
                rankdir=LR;
                labelloc=</span><span class="se">\"</span><span class="s">t</span><span class="se">\"</span><span class="s">;
                node [shape=circle, style=filled, fillcolor=lightblue, fontname=</span><span class="se">\"</span><span class="s">Arial</span><span class="se">\"</span><span class="s">];
                edge [fontcolor=blue, fontname=</span><span class="se">\"</span><span class="s">Arial</span><span class="se">\"</span><span class="s">];
                "</span><span class="p">,</span>
        <span class="p">);</span>

        <span class="c">// Define states</span>
        <span class="k">for</span> <span class="n">state</span> <span class="n">in</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.states</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">shape</span> <span class="o">=</span> <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.initial_state</span> <span class="p">{</span>
                <span class="s">"doublecircle"</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="s">"circle"</span>
            <span class="p">};</span>
            <span class="k">let</span> <span class="n">fillcolor</span> <span class="o">=</span> <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.initial_state</span> <span class="p">{</span>
                <span class="s">"lightgreen"</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="s">"lightblue"</span>
            <span class="p">};</span>
            <span class="k">let</span> <span class="n">width</span> <span class="o">=</span> <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.initial_state</span> <span class="p">{</span>
                <span class="s">"1.5"</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="s">"1.2"</span>
            <span class="p">};</span>
            <span class="k">let</span> <span class="n">height</span> <span class="o">=</span> <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.initial_state</span> <span class="p">{</span>
                <span class="s">"1.5"</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="s">"1.2"</span>
            <span class="p">};</span>
            <span class="n">dot</span><span class="nf">.push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">format!</span><span class="p">(</span>
                <span class="s">"  </span><span class="se">\"</span><span class="s">{}</span><span class="se">\"</span><span class="s"> [shape={}, fillcolor={}, width={}, height={}]; "</span><span class="p">,</span>
                <span class="n">state</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">fillcolor</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span>
            <span class="p">));</span>
        <span class="p">}</span>

        <span class="c">// Define transitions</span>
        <span class="k">for</span> <span class="n">transition</span> <span class="n">in</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.transitions</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">condition</span> <span class="o">=</span> <span class="k">match</span> <span class="o">&amp;</span><span class="n">transition</span><span class="py">.condition</span> <span class="p">{</span>
                <span class="nn">Condition</span><span class="p">::</span><span class="nf">OR</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"[{}]"</span><span class="p">,</span> <span class="n">symbols</span><span class="nf">.join</span><span class="p">(</span><span class="s">","</span><span class="p">)),</span>
                <span class="nn">Condition</span><span class="p">::</span><span class="n">Star</span> <span class="k">=&gt;</span> <span class="s">"*"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="p">};</span>
            <span class="k">let</span> <span class="n">steps</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">transition</span>
                <span class="py">.steps</span>
                <span class="nf">.iter</span><span class="p">()</span>
                <span class="nf">.map</span><span class="p">(|</span><span class="n">step</span><span class="p">|</span> <span class="k">match</span> <span class="n">step</span> <span class="p">{</span>
                    <span class="nn">TransitionStep</span><span class="p">::</span><span class="n">R</span> <span class="k">=&gt;</span> <span class="s">"R"</span><span class="nf">.to_string</span><span class="p">(),</span>
                    <span class="nn">TransitionStep</span><span class="p">::</span><span class="n">L</span> <span class="k">=&gt;</span> <span class="s">"L"</span><span class="nf">.to_string</span><span class="p">(),</span>
                    <span class="nn">TransitionStep</span><span class="p">::</span><span class="n">X</span> <span class="k">=&gt;</span> <span class="s">"X"</span><span class="nf">.to_string</span><span class="p">(),</span>
                    <span class="nn">TransitionStep</span><span class="p">::</span><span class="nf">P</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"P({})"</span><span class="p">,</span> <span class="n">func</span><span class="p">),</span>
                <span class="p">})</span>
                <span class="nf">.collect</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">label</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{} / {}"</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">steps</span><span class="nf">.join</span><span class="p">(</span><span class="s">"-"</span><span class="p">));</span>
            <span class="k">let</span> <span class="n">color</span> <span class="o">=</span> <span class="s">"black"</span><span class="p">;</span>
            <span class="n">dot</span><span class="nf">.push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">format!</span><span class="p">(</span>
                <span class="s">"  </span><span class="se">\"</span><span class="s">{}</span><span class="se">\"</span><span class="s"> -&gt; </span><span class="se">\"</span><span class="s">{}</span><span class="se">\"</span><span class="s"> [label=</span><span class="se">\"</span><span class="s">{}</span><span class="se">\"</span><span class="s">, color={}];
"</span><span class="p">,</span>
                <span class="n">transition</span><span class="py">.initial_state</span><span class="p">,</span> <span class="n">transition</span><span class="py">.final_state</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">color</span>
            <span class="p">));</span>
        <span class="p">}</span>

        <span class="n">dot</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">" } "</span><span class="p">);</span>
        <span class="n">dot</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Parser</span> <span class="p">{</span>
    <span class="n">lexer</span><span class="p">:</span> <span class="n">Lexer</span><span class="p">,</span>
    <span class="n">cur_token</span><span class="p">:</span> <span class="n">Token</span><span class="p">,</span>
    <span class="n">peek_token</span><span class="p">:</span> <span class="n">Token</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">tree</span><span class="p">:</span> <span class="n">ParseTree</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Parser</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">lexer</span><span class="p">:</span> <span class="n">Lexer</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
        <span class="nd">info!</span><span class="p">(</span><span class="s">"Initializing Parser"</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">parser</span> <span class="o">=</span> <span class="n">Parser</span> <span class="p">{</span>
            <span class="n">lexer</span><span class="p">,</span>
            <span class="n">cur_token</span><span class="p">:</span> <span class="n">Token</span> <span class="p">{</span>
                <span class="n">text</span><span class="p">:</span> <span class="s">"</span><span class="se">\0</span><span class="s">"</span><span class="nf">.to_string</span><span class="p">(),</span>
                <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">EOF</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="n">peek_token</span><span class="p">:</span> <span class="n">Token</span> <span class="p">{</span>
                <span class="n">text</span><span class="p">:</span> <span class="s">"</span><span class="se">\0</span><span class="s">"</span><span class="nf">.to_string</span><span class="p">(),</span>
                <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">EOF</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="n">tree</span><span class="p">:</span> <span class="n">ParseTree</span> <span class="p">{</span>
                <span class="n">states</span><span class="p">:</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
                <span class="n">initial_state</span><span class="p">:</span> <span class="s">""</span><span class="nf">.to_string</span><span class="p">(),</span>
                <span class="n">symbols</span><span class="p">:</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
                <span class="n">transitions</span><span class="p">:</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
            <span class="p">},</span>
        <span class="p">};</span>
        <span class="n">parser</span><span class="nf">.next_token</span><span class="p">();</span> <span class="c">// Initialize peek_token</span>
        <span class="n">parser</span><span class="nf">.next_token</span><span class="p">();</span> <span class="c">// Initialize cur_token</span>
        <span class="n">parser</span>
    <span class="p">}</span>

    <span class="c">// Check if the current token matches the expected token type</span>
    <span class="k">fn</span> <span class="nf">check_token</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">kind</span><span class="p">:</span> <span class="n">TokenType</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.cur_token.kind</span> <span class="o">==</span> <span class="n">kind</span>
    <span class="p">}</span>

    <span class="c">// Check if the next token has the expected token type</span>
    <span class="k">fn</span> <span class="nf">check_peek</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">kind</span><span class="p">:</span> <span class="n">TokenType</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.peek_token.kind</span> <span class="o">==</span> <span class="n">kind</span>
    <span class="p">}</span>

    <span class="c">// Advance to the next token</span>
    <span class="k">fn</span> <span class="nf">next_token</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.cur_token</span> <span class="o">=</span> <span class="k">self</span><span class="py">.peek_token</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="k">self</span><span class="py">.peek_token</span> <span class="o">=</span> <span class="k">self</span><span class="py">.lexer</span><span class="nf">.get_token</span><span class="p">()</span><span class="nf">.unwrap_or</span><span class="p">(</span><span class="n">Token</span> <span class="p">{</span>
            <span class="n">text</span><span class="p">:</span> <span class="s">"</span><span class="se">\0</span><span class="s">"</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">EOF</span><span class="p">,</span>
        <span class="p">});</span>

        <span class="c">// If both current and peek token are newline, skip the newline</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.check_token</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">NEWLINE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="k">self</span><span class="nf">.check_peek</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">NEWLINE</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.next_token</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c">// Abort the parsing process with an error message</span>
    <span class="k">fn</span> <span class="nf">abort</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">error!</span><span class="p">(</span><span class="s">"Parsing error: {}"</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>
        <span class="nd">panic!</span><span class="p">(</span><span class="s">"Parsing error: {}"</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c">// Try to consume the current token if it matches the expected token type</span>
    <span class="c">// If successful, print the token type and text (if available) and execute the optional action</span>
    <span class="c">// Return true if the token was consumed, false otherwise</span>
    <span class="k">fn</span> <span class="n">try_consume</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">kind</span><span class="p">:</span> <span class="n">TokenType</span><span class="p">,</span> <span class="n">action</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span>
    <span class="k">where</span>
        <span class="n">F</span><span class="p">:</span> <span class="nf">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">),</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.check_token</span><span class="p">(</span><span class="n">kind</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">match</span> <span class="n">kind</span> <span class="p">{</span>
                <span class="nn">TokenType</span><span class="p">::</span><span class="n">IDENT</span> <span class="k">=&gt;</span> <span class="nd">debug!</span><span class="p">(</span><span class="s">"{:?}: {}"</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="k">self</span><span class="py">.cur_token.text</span><span class="p">),</span>
                <span class="mi">_</span> <span class="k">=&gt;</span> <span class="nd">debug!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">kind</span><span class="p">),</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="k">mut</span> <span class="n">action</span><span class="p">)</span> <span class="o">=</span> <span class="n">action</span> <span class="p">{</span>
                <span class="nf">action</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.cur_token</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">self</span><span class="nf">.next_token</span><span class="p">();</span>
            <span class="k">true</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">false</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c">// Consume the current token if it matches the expected token type</span>
    <span class="c">// If not, abort with an error message</span>
    <span class="c">// Execute the optional action if provided</span>
    <span class="k">fn</span> <span class="n">consume</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">expected</span><span class="p">:</span> <span class="n">TokenType</span><span class="p">,</span> <span class="n">action</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="k">where</span>
        <span class="n">F</span><span class="p">:</span> <span class="nf">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">),</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="o">!</span><span class="k">self</span><span class="nf">.try_consume</span><span class="p">(</span><span class="n">expected</span><span class="p">,</span> <span class="n">action</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.abort</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">format!</span><span class="p">(</span>
                <span class="s">"Expected {:?}, got {:?}"</span><span class="p">,</span>
                <span class="n">expected</span><span class="p">,</span> <span class="k">self</span><span class="py">.cur_token.kind</span>
            <span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c">// Parse an initial state identifier: [IDENT]</span>
    <span class="k">fn</span> <span class="nf">initial_state_identifier</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">LeftBracket</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">initial_state</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span>
            <span class="nn">TokenType</span><span class="p">::</span><span class="n">IDENT</span><span class="p">,</span>
            <span class="nf">Some</span><span class="p">(|</span><span class="n">token</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Token</span><span class="p">|</span> <span class="p">{</span>
                <span class="n">initial_state</span><span class="nf">.push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="n">token</span><span class="py">.text</span><span class="p">);</span>
            <span class="p">}),</span>
        <span class="p">);</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.tree.initial_state</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.tree.initial_state</span> <span class="o">=</span> <span class="n">initial_state</span><span class="nf">.clone</span><span class="p">();</span>
            <span class="k">self</span><span class="py">.tree.states</span><span class="nf">.push</span><span class="p">(</span><span class="n">initial_state</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.abort</span><span class="p">(</span><span class="s">"Initial state already defined."</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">RightBracket</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>
        <span class="nd">debug!</span><span class="p">(</span><span class="s">"INITIAL_STATE_IDENTIFIER"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c">// Parse a list of state identifiers: IDENT (',' IDENT)*</span>
    <span class="k">fn</span> <span class="nf">state_identifier_list</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">state_identifiers</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

        <span class="c">// Consume all tokens</span>
        <span class="k">while</span> <span class="k">self</span><span class="nf">.check_token</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">IDENT</span><span class="p">)</span> <span class="p">||</span> <span class="k">self</span><span class="nf">.check_token</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">LeftBracket</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">self</span><span class="nf">.check_token</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">LeftBracket</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.initial_state_identifier</span><span class="p">();</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">!</span><span class="k">self</span><span class="nf">.try_consume</span><span class="p">(</span>
                <span class="nn">TokenType</span><span class="p">::</span><span class="n">IDENT</span><span class="p">,</span>
                <span class="nf">Some</span><span class="p">(|</span><span class="n">token</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Token</span><span class="p">|</span> <span class="p">{</span>
                    <span class="n">state_identifiers</span><span class="nf">.push</span><span class="p">(</span><span class="n">token</span><span class="py">.text</span><span class="nf">.clone</span><span class="p">());</span>
                <span class="p">}),</span>
            <span class="p">)</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="o">!</span><span class="k">self</span><span class="nf">.try_consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">COMMA</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
                <span class="nd">debug!</span><span class="p">(</span><span class="s">"STATE_IDENTIFIER_LIST"</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="k">self</span><span class="py">.tree.initial_state</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.abort</span><span class="p">(</span><span class="s">"Initial state not defined."</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c">// If state identifiers have duplicates, abort with an error message</span>
        <span class="n">state_identifiers</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.for_each</span><span class="p">(|</span><span class="n">state_identifier</span><span class="p">|</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">self</span><span class="py">.tree.states</span><span class="nf">.contains</span><span class="p">(</span><span class="n">state_identifier</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.abort</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">format!</span><span class="p">(</span><span class="s">"State {} already defined."</span><span class="p">,</span> <span class="n">state_identifier</span><span class="p">));</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.tree.states</span><span class="nf">.push</span><span class="p">(</span><span class="n">state_identifier</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">});</span>
    <span class="p">}</span>

    <span class="c">// Parse a states declaration: STATES ':' state_identifier_list NEWLINE</span>
    <span class="k">fn</span> <span class="nf">states_declaration</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">STATES</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>
        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">COLON</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>
        <span class="k">self</span><span class="nf">.state_identifier_list</span><span class="p">();</span>
        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">NEWLINE</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>
        <span class="nd">debug!</span><span class="p">(</span><span class="s">"STATES_DECLARATION"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c">// Parse a list of symbol identifiers: IDENT (',' IDENT)*</span>
    <span class="k">fn</span> <span class="nf">symbol_identifiers</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">symbol_identifiers</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span>
            <span class="nn">TokenType</span><span class="p">::</span><span class="n">IDENT</span><span class="p">,</span>
            <span class="nf">Some</span><span class="p">(|</span><span class="n">token</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Token</span><span class="p">|</span> <span class="p">{</span>
                <span class="n">symbol_identifiers</span><span class="nf">.push</span><span class="p">(</span><span class="n">token</span><span class="py">.text</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="p">}),</span>
        <span class="p">);</span>

        <span class="k">while</span> <span class="k">self</span><span class="nf">.try_consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">COMMA</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span>
                <span class="nn">TokenType</span><span class="p">::</span><span class="n">IDENT</span><span class="p">,</span>
                <span class="nf">Some</span><span class="p">(|</span><span class="n">token</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Token</span><span class="p">|</span> <span class="p">{</span>
                    <span class="n">symbol_identifiers</span><span class="nf">.push</span><span class="p">(</span><span class="n">token</span><span class="py">.text</span><span class="nf">.clone</span><span class="p">());</span>
                <span class="p">}),</span>
            <span class="p">);</span>
        <span class="p">}</span>
        <span class="n">symbol_identifiers</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.for_each</span><span class="p">(|</span><span class="n">symbol_identifier</span><span class="p">|</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">self</span><span class="py">.tree.symbols</span><span class="nf">.contains</span><span class="p">(</span><span class="n">symbol_identifier</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.abort</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">format!</span><span class="p">(</span><span class="s">"Symbol {} already defined."</span><span class="p">,</span> <span class="n">symbol_identifier</span><span class="p">));</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.tree.symbols</span><span class="nf">.push</span><span class="p">(</span><span class="n">symbol_identifier</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">});</span>

        <span class="c">// X is a special symbol</span>
        <span class="k">self</span><span class="py">.tree.symbols</span><span class="nf">.push</span><span class="p">(</span><span class="s">"X"</span><span class="nf">.to_string</span><span class="p">());</span>
        <span class="nd">debug!</span><span class="p">(</span><span class="s">"SYMBOL_IDENTIFIERS"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c">// Parse a symbols declaration: SYMBOLS ':' symbol_identifiers NEWLINE</span>
    <span class="k">fn</span> <span class="nf">symbols_declaration</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">SYMBOLS</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>
        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">COLON</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>
        <span class="k">self</span><span class="nf">.symbol_identifiers</span><span class="p">();</span>
        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">NEWLINE</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>
        <span class="nd">debug!</span><span class="p">(</span><span class="s">"SYMBOLS_DECLARATION"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c">// Parse a transition step: R | L | P '(' IDENT ')' | X</span>
    <span class="k">fn</span> <span class="nf">transition_step</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="c">// By default, do nothing</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">step</span><span class="p">:</span> <span class="n">TransitionStep</span> <span class="o">=</span> <span class="nn">TransitionStep</span><span class="p">::</span><span class="n">X</span><span class="p">;</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.try_consume</span><span class="p">(</span>
            <span class="nn">TokenType</span><span class="p">::</span><span class="n">R</span><span class="p">,</span>
            <span class="nf">Some</span><span class="p">(|</span><span class="n">token</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Token</span><span class="p">|</span> <span class="p">{</span>
                <span class="n">step</span> <span class="o">=</span> <span class="nn">FromTokenAndValue</span><span class="p">::</span><span class="nf">from_token_and_value</span><span class="p">(</span><span class="o">&amp;</span><span class="n">token</span><span class="nf">.clone</span><span class="p">(),</span> <span class="nb">None</span><span class="p">);</span>
            <span class="p">}),</span>
        <span class="p">)</span> <span class="p">{</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="k">self</span><span class="nf">.try_consume</span><span class="p">(</span>
            <span class="nn">TokenType</span><span class="p">::</span><span class="n">L</span><span class="p">,</span>
            <span class="nf">Some</span><span class="p">(|</span><span class="n">token</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Token</span><span class="p">|</span> <span class="p">{</span>
                <span class="n">step</span> <span class="o">=</span> <span class="nn">FromTokenAndValue</span><span class="p">::</span><span class="nf">from_token_and_value</span><span class="p">(</span><span class="o">&amp;</span><span class="n">token</span><span class="nf">.clone</span><span class="p">(),</span> <span class="nb">None</span><span class="p">);</span>
            <span class="p">}),</span>
        <span class="p">)</span> <span class="p">{</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="k">self</span><span class="nf">.try_consume</span><span class="p">(</span>
            <span class="nn">TokenType</span><span class="p">::</span><span class="n">X</span><span class="p">,</span>
            <span class="nf">Some</span><span class="p">(|</span><span class="n">token</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Token</span><span class="p">|</span> <span class="p">{</span>
                <span class="n">step</span> <span class="o">=</span> <span class="nn">FromTokenAndValue</span><span class="p">::</span><span class="nf">from_token_and_value</span><span class="p">(</span><span class="o">&amp;</span><span class="n">token</span><span class="nf">.clone</span><span class="p">(),</span> <span class="nb">None</span><span class="p">);</span>
            <span class="p">}),</span>
        <span class="p">)</span> <span class="p">{</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="k">self</span><span class="nf">.try_consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">P</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">LeftParen</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">print_string</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
            <span class="c">// Either X or a symbol identifier</span>
            <span class="k">if</span> <span class="k">self</span><span class="nf">.try_consume</span><span class="p">(</span>
                <span class="nn">TokenType</span><span class="p">::</span><span class="n">X</span><span class="p">,</span>
                <span class="nf">Some</span><span class="p">(|</span><span class="n">token</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Token</span><span class="p">|</span> <span class="p">{</span>
                    <span class="n">print_string</span><span class="nf">.push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="n">token</span><span class="py">.text</span><span class="p">);</span>
                <span class="p">}),</span>
            <span class="p">)</span> <span class="p">{</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span>
                    <span class="nn">TokenType</span><span class="p">::</span><span class="n">IDENT</span><span class="p">,</span>
                    <span class="nf">Some</span><span class="p">(|</span><span class="n">step</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Token</span><span class="p">|</span> <span class="p">{</span>
                        <span class="n">print_string</span><span class="nf">.push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="n">step</span><span class="py">.text</span><span class="p">);</span>
                    <span class="p">}),</span>
                <span class="p">)</span>
            <span class="p">};</span>

            <span class="k">if</span> <span class="o">!</span><span class="k">self</span><span class="py">.tree.symbols</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">print_string</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.abort</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">format!</span><span class="p">(</span>
                    <span class="s">"Symbol {} not defined, So cannot be printed."</span><span class="p">,</span>
                    <span class="n">print_string</span>
                <span class="p">));</span>
            <span class="p">}</span>
            <span class="n">step</span> <span class="o">=</span> <span class="nn">FromTokenAndValue</span><span class="p">::</span><span class="nf">from_token_and_value</span><span class="p">(</span>
                <span class="o">&amp;</span><span class="n">Token</span> <span class="p">{</span>
                    <span class="n">text</span><span class="p">:</span> <span class="s">"P"</span><span class="nf">.to_string</span><span class="p">(),</span>
                    <span class="n">kind</span><span class="p">:</span> <span class="nn">TokenType</span><span class="p">::</span><span class="n">P</span><span class="p">,</span>
                <span class="p">},</span>
                <span class="nf">Some</span><span class="p">(</span><span class="n">print_string</span><span class="p">),</span>
            <span class="p">);</span>

            <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">RightParen</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.abort</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">format!</span><span class="p">(</span>
                <span class="s">"Expected {:?} or {:?} or {:?} or {:?} as an action step, got {:?}: {:?}"</span><span class="p">,</span>
                <span class="nn">TokenType</span><span class="p">::</span><span class="n">R</span><span class="p">,</span>
                <span class="nn">TokenType</span><span class="p">::</span><span class="n">L</span><span class="p">,</span>
                <span class="nn">TokenType</span><span class="p">::</span><span class="n">P</span><span class="p">,</span>
                <span class="nn">TokenType</span><span class="p">::</span><span class="n">X</span><span class="p">,</span>
                <span class="k">self</span><span class="py">.cur_token.kind</span><span class="p">,</span>
                <span class="k">self</span><span class="py">.cur_token.text</span>
            <span class="p">));</span>
        <span class="p">}</span>
        <span class="k">self</span><span class="py">.tree.transitions</span><span class="nf">.last_mut</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.steps</span><span class="nf">.push</span><span class="p">(</span><span class="n">step</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">transition_steps</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.transition_step</span><span class="p">();</span>
        <span class="k">while</span> <span class="k">self</span><span class="nf">.try_consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">DASH</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.transition_step</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="nd">debug!</span><span class="p">(</span><span class="s">"TRANSITION_STEPS"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c">// Parse a list of transition conditions: IDENT ('|' IDENT)*</span>
    <span class="k">fn</span> <span class="nf">transition_condition_list</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">conditions</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

        <span class="c">// Consume X as well</span>
        <span class="k">if</span> <span class="k">self</span><span class="nf">.try_consume</span><span class="p">(</span>
            <span class="nn">TokenType</span><span class="p">::</span><span class="n">X</span><span class="p">,</span>
            <span class="nf">Some</span><span class="p">(|</span><span class="n">token</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Token</span><span class="p">|</span> <span class="p">{</span>
                <span class="n">conditions</span><span class="nf">.push</span><span class="p">(</span><span class="n">token</span><span class="py">.text</span><span class="nf">.clone</span><span class="p">());</span>
            <span class="p">}),</span>
        <span class="p">)</span> <span class="p">{</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span>
                <span class="nn">TokenType</span><span class="p">::</span><span class="n">IDENT</span><span class="p">,</span>
                <span class="nf">Some</span><span class="p">(|</span><span class="n">token</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Token</span><span class="p">|</span> <span class="p">{</span>
                    <span class="n">conditions</span><span class="nf">.push</span><span class="p">(</span><span class="n">token</span><span class="py">.text</span><span class="nf">.clone</span><span class="p">());</span>
                <span class="p">}),</span>
            <span class="p">);</span>
        <span class="p">}</span>

        <span class="k">while</span> <span class="k">self</span><span class="nf">.try_consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">OR</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
            <span class="c">// Consume X as well</span>
            <span class="k">if</span> <span class="k">self</span><span class="nf">.try_consume</span><span class="p">(</span>
                <span class="nn">TokenType</span><span class="p">::</span><span class="n">X</span><span class="p">,</span>
                <span class="nf">Some</span><span class="p">(|</span><span class="n">token</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Token</span><span class="p">|</span> <span class="p">{</span>
                    <span class="n">conditions</span><span class="nf">.push</span><span class="p">(</span><span class="n">token</span><span class="py">.text</span><span class="nf">.clone</span><span class="p">());</span>
                <span class="p">}),</span>
            <span class="p">)</span> <span class="p">{</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span>
                    <span class="nn">TokenType</span><span class="p">::</span><span class="n">IDENT</span><span class="p">,</span>
                    <span class="nf">Some</span><span class="p">(|</span><span class="n">token</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Token</span><span class="p">|</span> <span class="p">{</span>
                        <span class="n">conditions</span><span class="nf">.push</span><span class="p">(</span><span class="n">token</span><span class="py">.text</span><span class="nf">.clone</span><span class="p">());</span>
                    <span class="p">}),</span>
                <span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">self</span><span class="py">.tree.transitions</span><span class="nf">.last_mut</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.condition</span> <span class="o">=</span> <span class="nn">Condition</span><span class="p">::</span><span class="nf">OR</span><span class="p">(</span><span class="n">conditions</span><span class="p">);</span>
        <span class="nd">debug!</span><span class="p">(</span><span class="s">"TRANSITION_CONDITION_LIST"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c">// Parse transition conditions: '*' | transition_condition_list</span>
    <span class="k">fn</span> <span class="nf">transition_conditions</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">star_condition</span> <span class="o">=</span> <span class="k">false</span><span class="p">;</span>
        <span class="k">if</span> <span class="o">!</span><span class="k">self</span><span class="nf">.try_consume</span><span class="p">(</span>
            <span class="nn">TokenType</span><span class="p">::</span><span class="n">STAR</span><span class="p">,</span>
            <span class="nf">Some</span><span class="p">(|</span><span class="mi">_</span><span class="n">token</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Token</span><span class="p">|</span> <span class="p">{</span>
                <span class="n">star_condition</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">}),</span>
        <span class="p">)</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.transition_condition_list</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="c">// Override all other conditions with the star condition</span>
        <span class="k">if</span> <span class="n">star_condition</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.tree.transitions</span><span class="nf">.last_mut</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.condition</span> <span class="o">=</span> <span class="nn">Condition</span><span class="p">::</span><span class="n">Star</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nd">debug!</span><span class="p">(</span><span class="s">"TRANSITION_CONDITIONS"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c">// Parse a transition declaration:</span>
    <span class="c">// IDENT ',' transition_conditions ',' transition_steps ',' IDENT</span>
    <span class="k">fn</span> <span class="nf">transition_declaration</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="c">// Initialize a new transition</span>
        <span class="k">self</span><span class="py">.tree.transitions</span><span class="nf">.push</span><span class="p">(</span><span class="nn">Transition</span><span class="p">::</span><span class="nf">new</span><span class="p">());</span>

        <span class="c">// Initial state</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">initial_state</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span>
            <span class="nn">TokenType</span><span class="p">::</span><span class="n">IDENT</span><span class="p">,</span>
            <span class="nf">Some</span><span class="p">(|</span><span class="n">token</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Token</span><span class="p">|</span> <span class="p">{</span>
                <span class="n">initial_state</span><span class="nf">.push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="n">token</span><span class="py">.text</span><span class="p">);</span>
            <span class="p">}),</span>
        <span class="p">);</span>
        <span class="k">self</span><span class="py">.tree.transitions</span><span class="nf">.last_mut</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.initial_state</span> <span class="o">=</span> <span class="n">initial_state</span><span class="p">;</span>

        <span class="nd">debug!</span><span class="p">(</span><span class="s">"INITIAL_STATE_IDENTIFIER"</span><span class="p">);</span>
        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">COMMA</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>

        <span class="c">// Conditions</span>
        <span class="k">self</span><span class="nf">.transition_conditions</span><span class="p">();</span>
        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">COMMA</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>

        <span class="c">// Actions</span>
        <span class="k">self</span><span class="nf">.transition_steps</span><span class="p">();</span>
        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">COMMA</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>

        <span class="c">// Final state</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">final_state</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span>
            <span class="nn">TokenType</span><span class="p">::</span><span class="n">IDENT</span><span class="p">,</span>
            <span class="nf">Some</span><span class="p">(|</span><span class="n">token</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Token</span><span class="p">|</span> <span class="p">{</span>
                <span class="n">final_state</span><span class="nf">.push_str</span><span class="p">(</span><span class="o">&amp;</span><span class="n">token</span><span class="py">.text</span><span class="p">);</span>
            <span class="p">}),</span>
        <span class="p">);</span>
        <span class="k">self</span><span class="py">.tree.transitions</span><span class="nf">.last_mut</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.final_state</span> <span class="o">=</span> <span class="n">final_state</span><span class="p">;</span>
        <span class="nd">debug!</span><span class="p">(</span><span class="s">"FINAL_STATE_IDENTIFIER"</span><span class="p">);</span>
        <span class="nd">debug!</span><span class="p">(</span><span class="s">"TRANSITION_DECLARATION"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c">// Parse transitions declarations:</span>
    <span class="c">// TRANSITIONS ':' (NEWLINE transition_declaration)*</span>
    <span class="k">fn</span> <span class="nf">transitions_declaration</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">TRANSITIONS</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>
        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">COLON</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>

        <span class="k">while</span> <span class="k">self</span><span class="nf">.try_consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">NEWLINE</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">self</span><span class="nf">.check_token</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">EOF</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">self</span><span class="nf">.transition_declaration</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="nd">debug!</span><span class="p">(</span><span class="s">"TRANSITION_DECLARATIONS"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c">// Parse the entire program:</span>
    <span class="c">// NEWLINE? states_declaration symbols_declaration transitions_declaration NEWLINE? EOF</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">program</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="c">// Consume newlines</span>
        <span class="k">while</span> <span class="k">self</span><span class="nf">.try_consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">NEWLINE</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{}</span>
        <span class="k">self</span><span class="nf">.states_declaration</span><span class="p">();</span>
        <span class="k">self</span><span class="nf">.symbols_declaration</span><span class="p">();</span>
        <span class="k">self</span><span class="nf">.transitions_declaration</span><span class="p">();</span>
        <span class="c">// Consume newlines</span>
        <span class="k">while</span> <span class="k">self</span><span class="nf">.try_consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">NEWLINE</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{}</span>
        <span class="k">self</span><span class="nf">.consume</span><span class="p">(</span><span class="nn">TokenType</span><span class="p">::</span><span class="n">EOF</span><span class="p">,</span> <span class="nn">None</span><span class="p">::</span><span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Token</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>
        <span class="nd">debug!</span><span class="p">(</span><span class="s">"PROGRAM"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>


</details>

<h2 id="conclusion">Conclusion</h2>

<p>We were able to generate the rust code for the state machine, with
very minimal specification. You can find the full code and instructions to run <a href="https://github.com/mabhay3420/state_machine_compile_rust">here</a>.</p>

<p>One thing still bugs me: at the end of the day, we just substituted the parsed
values within the program. Can we actually construct the program as in:</p>
<ol>
  <li>Creating a module</li>
  <li>Defining functions inside it</li>
  <li>Writing the logic using these functions.</li>
</ol>

<p>We can go a level deeper and work with LLVM IR. We won’t try to have all bells
and whistles, but just simulate the state machine and print the result.</p>

<p>That is the content of the [next post][link_here].</p>

      </article>

      

      

      
        <!-- Check if any share-links are active -->




<section id = "social-share-section">
  <span class="sr-only">Share: </span>

  
    <a href="https://twitter.com/intent/tweet?text=State+Machine+Compiler+-+A+Small+Language&url=http%3A%2F%2Flocalhost%3A4000%2F2024-05-07-state-machine-compiler-a-small-language%2F"
      class="btn btn-social-icon btn-twitter" title="Share on Twitter">
      <span class="fab fa-fw fa-twitter" aria-hidden="true"></span>
      <span class="sr-only">Twitter</span>
    </a>
  

  
    <a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Flocalhost%3A4000%2F2024-05-07-state-machine-compiler-a-small-language%2F"
      class="btn btn-social-icon btn-facebook" title="Share on Facebook">
      <span class="fab fa-fw fa-facebook" aria-hidden="true"></span>
      <span class="sr-only">Facebook</span>
    </a>
  

  
    <a href="https://www.linkedin.com/shareArticle?mini=true&url=http%3A%2F%2Flocalhost%3A4000%2F2024-05-07-state-machine-compiler-a-small-language%2F"
      class="btn btn-social-icon btn-linkedin" title="Share on LinkedIn">
      <span class="fab fa-fw fa-linkedin" aria-hidden="true"></span>
      <span class="sr-only">LinkedIn</span>
    </a>
  

  

</section>



      

      <ul class="pagination blog-pager">
        
        <li class="page-item previous">
          <a class="page-link" href="/2024-05-05-state-machine-compiler-rust-macros/" data-toggle="tooltip" data-placement="top" title="State Machine Compiler - Rust Macros">&larr; Previous Post</a>
        </li>
        
        
      </ul>
      
  <div class="disqus-comments">
  <div class="comments">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
	  var disqus_shortname = 'mabhay3420-github-io';
	  /* ensure that pages with query string get the same discussion */
	  var url_parts = window.location.href.split("?");
	  var disqus_url = url_parts[0];
	  (function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</div>
  
  

  




    </div>
  </div>
</div>


  <footer>
  <div class="container-md beautiful-jekyll-footer">
    <div class="row">
      <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
      <ul class="list-inline text-center footer-links"><li class="list-inline-item">
    <a href="mailto:abhaymishra3420@gmail.com" title="Email me">
      <span class="fa-stack fa-lg" aria-hidden="true">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
      </span>
      <span class="sr-only">Email me</span>
   </a>
  </li><li class="list-inline-item">
    <a href="https://www.facebook.com/invictusabhay" title="Facebook">
      <span class="fa-stack fa-lg" aria-hidden="true">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fab fa-facebook fa-stack-1x fa-inverse"></i>
      </span>
      <span class="sr-only">Facebook</span>
   </a>
  </li><li class="list-inline-item">
    <a href="https://github.com/mabhay3420" title="GitHub">
      <span class="fa-stack fa-lg" aria-hidden="true">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fab fa-github fa-stack-1x fa-inverse"></i>
      </span>
      <span class="sr-only">GitHub</span>
   </a>
  </li></ul>

      
      <p class="copyright text-muted">
      
        Abhay mishra
        &nbsp;&bull;&nbsp;
      
      2024

      
        &nbsp;&bull;&nbsp;
        <span class="author-site">
          <a href="http://localhost:4000/">INVICTUS</a>
        </span>
      

      
      </p>
      <p class="theme-by text-muted">
        Powered by
        <a href="https://beautifuljekyll.com">Beautiful Jekyll</a>
      </p>
      </div>
    </div>
  </div>
</footer>


  
  
    
  <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" crossorigin="anonymous"></script>


  
    
  <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>


  
    
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>


  



  
    <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
    
      <script src="/assets/js/beautifuljekyll.js"></script>
    
  









</body>
</html>
